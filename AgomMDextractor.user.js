// ==UserScript==
// @name         Agom Markdown提取器
// @namespace    http://tampermonkey.net/
// @version      0.9
// @description  突破性iframe内容提取：多重提取策略（直接访问、消息通信、URL获取）、智能内容检测、用户指导系统。彻底解决跨域iframe内容提取难题，通过DOM分析和postMessage实现跨iframe的内容提取、Markdown转换和DOM结构预览。
// @author       Agom Liou vx：Uncleliou
// @match        *://*/*
// @grant        none
// ==/UserScript==

(function() {
    'use strict';

    const SCRIPT_VERSION = '0.9';
    const isTopWindow = window.self === window.top;
    let selectionContext = { source: 'top', selector: null, iframeId: null };

    // 收款码base64数据
    const PAYMENT_QR_BASE64 = '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2Ldv33k5q67rtGrViujoaPbu3UtNTY33C5BlunXrhtvtZteuXefcLyEhgfT0dE6ePElBQcE563bt2hWLxcLWrVsxmUx07drVeI6ysjIOHz5MQkICaWlpaJqGKIocPXqUkpISOnToQHBwMLt27cLhcPxuidDwWRru108gf0DVSpIknnjiCb799tt/6rMPPfQQb775Jh6PB1EUkWXZQARN0xg8eDBFRUUUFRURGRmJJEns37+fvn37XnDNRYsWcdtttzFu3Dh2795tEEhZWRlFRUX06dPnnM/cc889vPPOO7zyyivMnTv3nNePHz9OkyZNuPzyy4mKiqKkpMR4bdOmTQwbNoz77ruPv//97yiKgtls5umnn+arr75i48aN9O7dm5tuuons7Ox/6nzmz5/PmDFjUFXVYBB+AvmDgtVqRRRFFixYQLt27QgODsZkatzdz+l0UldXx5o1a3jssccICPCOWzObvR0IH374YZYsWcK3335Lx44dMZvN2Gw2YmJicDgc9O7dm8rKSgAGDBjAwoULqaysxO1287e//Y158+YZa37++ec4nU7DDggJCcHj8SDLskHUiqKg6zoWiwVZlpk9ezYvvPACjzzyCF9//TVLliyha9euREdHI4oi+/fvJz8/nyZNvCMTdF2nd+/e7Nmzh7Aw79Sm9957j48//pgHHniAZ555hvT0dAACAgKwWCysWrWKiIgIQkNDz5EKdrsdl8vF22+/zUcffYTFYvGrWJeSqqVpGm3atKFdu3YsXLiQ6upqQ/fWNI24uDhuvPFGTp8+jaZphtH7448/smvXLgIDA7n55puJi4tDFEUkScLlcvHiiy9SXV1NZmYmkZGRTJ48mYCAAD777DO6detG7969iY6ORlVVw4Bv0aJFo/3Nnj2b7Oxsw1j2eDw0a9aMESNGIIoi06ZNw2q1EhgYyMmTJ1EUhQ0bNlBYWMjNN99MeHg4bdu2JS0tjZtvvtlYp0uXLnTo0MG4T05ODnv27CEmJoaOHTueY7T36NEDURT54IMPDFVUFEVUVaV9+/b07t2bmJiY33RE+AnkDwx1dXVomsYDDzxAVVVVo9dat27NsGHDqKurM5AGYO3atbz99tssXLiQwYMHU1FRQU5ODpIkIQgC06dPN7xEbdu25fXXX2fVqlUMHTqUsWPHkpiYiMfjITExEZvNO8PPp7YVFBRQ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fDmZmZl06tQJ8FbgJScnU1FRYWS1KorCihUruPPOO4013njjDdauXcuwYcN47LHHWLduHd27d2f06NFGPlKTJk04ffr0Off2IY6vpv2JJ55g+fLlRmeUxMRE8vPzjWE+DdUhH9x///2sX7+eRx55hP79+zNv3jxGjRrF6NGj2bdvH6IoEh0dTVFREdHR0axdu5ZDhw5x2WWXYTabqaur44MPPjDmEfrmDgI899xzF1RNfdJPFEXcbjfDhw/nrbfe4vHHH2fYsGF8+umnjBw5ElVVL+mCqT+Fm9enfviIw4coZ86cobKykpqaGjZs2IAsy4wbNw673U5RURG5ubmcOnUKm83GmjVrMJlMREdHY7Va2bt3LwcOHGik2/u8Qd988w1BQUE8/fTThuSQZdnQ2X37stls2Gw2tmzZYswqr6ioICcnh48++ghJkrBarXg8Hl566SXsdjsjR440pKLdbqeyspKsrCxiYmIMgzkjI4MDBw5w3XXXkZGRwd///nckSWLKlCkcO3aMa665BkVRWLZsGTk5OVRVVWG328nNzWXjxo0IgoCiKEZSp6IofPTRR6SkpBhqoL9pwyWkYi1fvtzQod1udyMiafhet9uN1WolICCAXr16ceWVV3L99dcTFhbGkiVLOHr0KC+88AIpKSk899xztGnThtdffx2n08nTTz9NkyZNmDBhAq1ateLpp5+me3dvwO/rr79m06ZNtGvXjg4dOvDpp5+yYMECiouLkSTJGF3w4osvkpSUxP33309sbKxhB5hMJjZs2MCWLVsYOXIkzZo148svv+TMmTPGczzyyCM4HA5ee+01UlJSuOeeezh48KBRp6KqKpGRkaSkpBASEmJ4rJKSkpgxYwaVlZVMmzbNsDuSk5N59NFH2bt3L5988gl1dXXY7Xauu+46+vfvb9S8+71Yl4CK9cEHH7By5UrCw8MbqRg++8Jng8iybLiA77vvPvr378+gQYMYNGgQiqLw7bffsnXrVjZt2sTEiRMJCgpi8uTJRtFVhw4dmDBhgkEoZrN3+tOePXv45JNPWLx4Mf3792fo0KFs2bIFu91OUFAQTqeTiooKPvjgAzp27Mg999xjdE8vLCzk2LFjvPfeeyxZsgSTycSNN97ISy+9xIkTJ4xnnThxIlVVVbzyyiukpKTQp08fjh07ZriBHQ6HUWLrc0j4nBOff/45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';

    // 每日提示功能
    const LAST_SHOW_DATE_KEY = 'agom_md_extractor_last_show_date';

    // 调试模式
    const DEBUG_MODE = true;
    function debugLog(...args) {
        if (DEBUG_MODE) {
            console.log(`[Agom MD提取器 DEBUG]`, ...args);
        }
    }

    // 全局工具栏管理器
    const ToolbarManager = {
        created: false,
        creating: false,
        instance: null,

        shouldCreateToolbar() {
            // 只有顶级窗口或者确定的独立iframe才能创建工具栏
            if (isTopWindow) return true;

            // 如果不是顶级窗口，检查是否能与父窗口通信
            try {
                window.parent.postMessage({ type: 'toolbar-check' }, '*');
                return false; // 能通信就不创建独立工具栏
            } catch (e) {
                return true; // 不能通信才创建独立工具栏
            }
        },

        createToolbar() {
            debugLog('ToolbarManager.createToolbar 被调用，当前状态:', {
                created: this.created,
                creating: this.creating,
                isTopWindow,
                url: window.location.href
            });

            if (this.created || this.creating) {
                debugLog('工具栏已存在或正在创建，跳过');
                return false;
            }

            if (!this.shouldCreateToolbar()) {
                debugLog('不应该在此环境创建工具栏');
                return false;
            }

            this.creating = true;
            debugLog('开始创建工具栏');

            // 移除所有可能的旧工具栏
            this.removeAllToolbars();

            try {
                const result = this._doCreateToolbar();
                if (result) {
                    this.created = true;
                    this.instance = document.getElementById(CONFIG.TOOLBAR_ID);
                    debugLog('工具栏创建成功');
                } else {
                    debugLog('工具栏创建失败');
                }
                return result;
            } finally {
                this.creating = false;
            }
        },

        removeAllToolbars() {
            const selectors = [
                `#${CONFIG.TOOLBAR_ID}`,
                '[id*="md-extractor-toolbar"]',
                '[id*="markdown-extractor"]',
                '.md-extractor-toolbar'
            ];

            selectors.forEach(selector => {
                const elements = document.querySelectorAll(selector);
                elements.forEach(el => {
                    console.log('[ToolbarManager] 移除工具栏:', el.id || el.className);
                    el.remove();
                });
            });

            this.created = false;
            this.instance = null;
        },

        _doCreateToolbar() {
            // 实际的工具栏创建逻辑
            return createFloatingToolbar();
        }
    };

    // 更全面的嵌套环境检测
    function detectNestingEnvironment() {
        const info = {
            isTopWindow: window.self === window.top,
            isInFrame: window.frameElement !== null,
            isInIframe: window.frameElement && window.frameElement.tagName === 'IFRAME',
            isInEmbed: window.frameElement && window.frameElement.tagName === 'EMBED',
            isInObject: window.frameElement && window.frameElement.tagName === 'OBJECT',
            hasParentWindow: window.parent !== window,
            canCommunicateWithParent: false,
            isInShadowDOM: false,
            shadowHost: null
        };

        try {
            // 测试是否可以与父窗口通信
            if (info.hasParentWindow) {
                window.parent.location.href;
                info.canCommunicateWithParent = true;
            }
        } catch (e) {
            info.canCommunicateWithParent = false;
        }

        // 检测Shadow DOM
        try {
            let currentNode = document.documentElement;
            while (currentNode) {
                if (currentNode.host && currentNode.host.shadowRoot) {
                    info.isInShadowDOM = true;
                    info.shadowHost = currentNode.host;
                    break;
                }
                currentNode = currentNode.parentNode;
            }
        } catch (e) {
            // Shadow DOM检测失败，忽略
        }

        return info;
    }

    const nestingInfo = detectNestingEnvironment();

    // =================================================================================
    // --- 配置中心 (Configuration Center) ---
    // =================================================================================
    const CONFIG = {
        POLL_INTERVAL: 1000,
        POLL_TIMEOUT: 20000,
        HIGHLIGHT_CLASS: 'md-extractor-highlighted',
        HOVER_HIGHLIGHT_CLASS: 'md-extractor-hover-highlight',
        TOOLBAR_ID: 'md-extractor-toolbar',
        JUNK_SELECTORS: [
            '.h-date-picker', '.h-year-picker', '.h-month-picker', '.h-calendar',
            '.h-select-dropdown', '.h-cascader-menus', 'div.h-dropdown-menu',
            'button:not(.selector-btn)', 'a.h-btn', '.h-page',
            '.h-poptip', '.h-tooltip', '[class*="tooltip"]',
            '.h-loading', 'div[class*="loading"]',
            '.h-modal-mask', '.h-modal-wrap',
            '[class*="icon"]:not([class*="form"])', 'i[class^="h-icon"]', 'svg',
            '.h-form-item-extra', '.h-form-item-help',
            '[style*="display: none"]', '[style*="display:none"]',
            'script', 'style', 'link', 'meta', 'title'
        ],
        // 需要特殊处理的onclick元素
        ONCLICK_JUNK_PATTERNS: [
            /展开/i, /收起/i, /更多/i, /\.{3}/,
            /置顶/i, /删除/i, /编辑/i, /设置/i,
            /上一页/i, /下一页/i, /第\s*\d+\s*页/i,
            /关闭/i, /取消/i, /确定/i, /返回/i
        ],
        IGNORE_TAGS: ['script', 'style', 'link', 'iframe', 'button', 'svg', 'canvas', 'video', 'audio', 'meta', 'title'],
        CLEANUP_KEYWORDS: [/批注/g, /展开$/g, /收起$/g, /更多$/g, /\s*…\s*展开$/g, /\s*…$/g, /^\s*$/, /\n\s*\n\s*\n/g],
    };

    // =================================================================================
    // --- 状态管理 (State Management) ---
    // =================================================================================
    let isInitialized = false;
    let isPickingMode = false;
    let lastHoveredElement = null;
    let statusTimeout = null;

    // =================================================================================
    // --- 初始化 (Initialization) ---
    // =================================================================================
    function waitForDOM() {
        return new Promise((resolve) => {
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', resolve);
            } else {
                resolve();
            }
        });
    }

    async function init() {
        try {
            await waitForDOM();

            // 等待body元素准备好
            let attempts = 0;
            const maxAttempts = 20;

            while (!document.body && attempts < maxAttempts) {
                await new Promise(resolve => setTimeout(resolve, CONFIG.POLL_INTERVAL));
                attempts++;
            }

            if (!document.body) {
                console.error('MD提取器: 初始化失败，未找到body元素');
                return;
            }

            if (!isInitialized) {
                initMarkdownExtractor();
            }
        } catch (error) {
            console.error('MD提取器: 初始化过程中出错:', error);
            // 如果初始化失败，等待一下重试
            setTimeout(() => {
                if (!isInitialized) {
                    console.log('MD提取器: 尝试重新初始化...');
                    init();
                }
            }, 2000);
        }
    }

    function initMarkdownExtractor() {
        if (isInitialized) return;

        try {
            isInitialized = true;

            console.log(`🚀 Agom Markdown提取器 v${SCRIPT_VERSION} 嵌套环境检测:`, nestingInfo);

            if (nestingInfo.isTopWindow) {
                console.log(`🚀 Agom Markdown提取器 v${SCRIPT_VERSION} 已启动！[Master]`);

                // 使用工具栏管理器创建工具栏
                ToolbarManager.createToolbar();
                addCustomStyles();
                window.addEventListener('message', handleFrameMessage, false);
            } else {
                // 在嵌套环境中的处理
                const nestingType = nestingInfo.isInShadowDOM ? 'shadow-dom' :
                                   nestingInfo.isInIframe ? 'iframe' :
                                   nestingInfo.isInEmbed ? 'embed' :
                                   nestingInfo.isInObject ? 'object' :
                                   nestingInfo.isInFrame ? 'frame' : 'unknown';

                console.log(`🚀 Markdown提取器 v${SCRIPT_VERSION} (诊断版) 已启动！[Nested-${nestingType}]`);

                // 根据嵌套类型和通信能力决定策略
                if (nestingInfo.canCommunicateWithParent) {
                    console.log('[MD Extractor] 可以与父窗口通信，尝试协同工作');
                    // 尝试与父窗口通信，如果失败则创建独立工具栏
                    let hasParentCommunication = false;

                    // 监听来自父窗口的消息
                    window.addEventListener('message', (event) => {
                        if (event.data.type === 'pong') {
                            hasParentCommunication = true;
                            console.log('[MD Extractor] 父窗口响应正常');
                        }
                        handleMasterMessage(event);
                    }, false);

                    // 确保iframe能接收选择模式消息
                    debugLog('iframe已绑定消息监听器，准备接收选择模式指令');

                    setTimeout(() => {
                        try {
                            window.parent.postMessage({ type: 'ping' }, '*');
                            console.log('[MD Extractor] 发送ping给父窗口');
                        } catch (e) {
                            console.log('[MD Extractor] 无法发送ping给父窗口');
                        }
                    }, 100);

                    // 等待父窗口响应，如果没有响应则创建独立工具栏
                    setTimeout(() => {
                        if (!hasParentCommunication) {
                            console.log('[MD Extractor] 父窗口无响应，尝试创建独立工具栏');
                            if (ToolbarManager.createToolbar()) {
                                addCustomStyles();
                            }
                        } else {
                            console.log('[MD Extractor] 父窗口响应正常，不创建独立工具栏');
                        }
                    }, 1000);
                } else {
                    console.log('[MD Extractor] 无法与父窗口通信，尝试创建独立工具栏');

                    // 即使无法通信，也要绑定消息监听器，以防后续能够接收消息
                    window.addEventListener('message', handleMasterMessage, false);
                    debugLog('无父通信iframe已绑定消息监听器');

                    if (ToolbarManager.createToolbar()) {
                        addCustomStyles();
                    }
                }
            }

                // 为 iframe 分配唯一 ID（针对OA系统优化）
                function assignIframeIds(container, prefix = '') {
                    const iframes = container.querySelectorAll('iframe');
                    iframes.forEach((iframe, index) => {
                        if (!iframe.id) {
                            // 尝试从src或其他属性生成更稳定的ID
                            let stableId = '';
                            if (iframe.src) {
                                const urlParts = iframe.src.split('/');
                                const fileName = urlParts[urlParts.length - 1];
                                if (fileName && fileName.length > 3) {
                                    stableId = fileName.replace(/[^a-zA-Z0-9]/g, '').substring(0, 15);
                                }
                            }

                            // 检查父容器的类名以确定iframe用途
                            const parentClass = iframe.parentElement?.className || '';
                            if (parentClass.includes('right-content')) {
                                stableId = 'main-content';
                            } else if (parentClass.includes('pending')) {
                                stableId = 'pending-frame';
                            } else if (parentClass.includes('collaboration')) {
                                stableId = 'collab-frame';
                            }

                            iframe.id = stableId ?
                                `mde-${stableId}-${index}` :
                                `mde-iframe-${prefix}${index}-${Date.now()}`;

                            console.log(`为iframe分配ID: ${iframe.id} (来源: ${stableId || 'default'})`);
                        }
                    });
                }

                assignIframeIds(document);

                // 监听新iframe的加载，为动态创建的iframe分配ID
                const observer = new MutationObserver(mutations => {
                    mutations.forEach(mutation => {
                        mutation.addedNodes.forEach(node => {
                            if (node.tagName === 'IFRAME') {
                                if (!node.id) {
                                    node.id = `mde-iframe-dynamic-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                                }
                            } else if (node.querySelectorAll) {
                                assignIframeIds(node, 'nested-');
                            }
                        });
                    });
                });

                observer.observe(document.body, {
                    childList: true,
                    subtree: true
                });


            console.log('✅ MD提取器初始化完成');
        } catch (error) {
            console.error('MD提取器初始化失败:', error);
            isInitialized = false;

            // 重试机制
            setTimeout(() => {
                console.log('MD提取器: 尝试重新初始化...');
                initMarkdownExtractor();
            }, 1000);
        }
    }

    // =================================================================================
    // --- 调试和状态检查 (Debug and Status Check) ---
    // =================================================================================
    function checkStatus() {
        console.log('=== MD提取器状态检查 ===');
        console.log('初始化状态:', isInitialized);
        console.log('document.readyState:', document.readyState);
        console.log('document.body 存在:', !!document.body);

        const toolbar = document.getElementById(CONFIG.TOOLBAR_ID);
        console.log('工具栏存在:', !!toolbar);

        if (toolbar) {
            console.log('工具栏可见:', toolbar.offsetParent !== null);
            console.log('工具栏样式:', toolbar.style.cssText);
        }

        const styles = document.getElementById('md-extractor-styles');
        console.log('样式表存在:', !!styles);

        console.log('========================');
    }

    // 暴露调试函数到全局
    window.MDExtractorDebug = {
        checkStatus,
        reinit: () => {
            isInitialized = false;
            init();
        },
        forceShow: () => {
            const toolbar = document.getElementById(CONFIG.TOOLBAR_ID);
            if (toolbar) {
                toolbar.style.display = 'block';
                toolbar.style.visibility = 'visible';
                toolbar.style.opacity = '1';
            }
        }
    };

    // 启动初始化 - 使用多种方式确保能够启动
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }

    // 备用启动方式
    setTimeout(() => {
        if (!isInitialized) {
            console.log('MD提取器: 备用启动方式...');
            init();
        }
    }, 1000);

    // 最后的保险措施
    window.addEventListener('load', () => {
        if (!isInitialized) {
            console.log('MD提取器: window.load 触发启动...');
            init();
        }
    });

    // 延迟状态检查
    setTimeout(() => {
        checkStatus();
        if (!isInitialized) {
            console.warn('⚠️  MD提取器未能正常初始化，请在控制台运行 MDExtractorDebug.reinit() 手动重新初始化');
        }
    }, 3000);

    // =================================================================================
    // --- UI 创建与样式 (UI Creation & Styling) ---
    // =================================================================================
    function createFloatingToolbar() {
        try {
            console.log('开始创建工具栏HTML结构');

            const toolbar = document.createElement('div');
            toolbar.id = CONFIG.TOOLBAR_ID;
            toolbar.innerHTML = `
                <div class="toolbar-header">
                    <span>📝 MD提取器 v${SCRIPT_VERSION}</span>
                    <button id="toggle-btn" title="折叠/展开">－</button>
                </div>
                <div class="toolbar-content">
                    <div class="main-controls">
                        <button id="element-picker-btn" class="btn-picker" title="点击后可在页面上选取要提取的区域">🖱️ 选择元素</button>
                        <button id="auto-detect-btn" class="btn-secondary" title="自动寻找页面上的主要内容区域">🎯 智能检测</button>
                    </div>
                    <div class="selector-group">
                        <label for="selector-input">CSS 选择器:</label>
                        <input type="text" id="selector-input" placeholder="点击上方按钮选择或手动输入">
                    </div>
                    <div class="options-group">
                        <label><input type="checkbox" id="auto-expand" checked> 自动展开</label>
                        <label><input type="checkbox" id="structured-mode" checked> 结构化</label>
                    </div>
                    <div class="action-buttons">
                         <button id="preview-btn">👀 预览</button>
                         <button id="extract-btn" class="btn-primary">📋 提取复制</button>
                    </div>
                    <div class="manual-actions">
                         <button id="export-html-btn" class="btn-secondary">📄 导出HTML</button>
                         <button id="manual-copy-btn" class="btn-secondary">📄 手动复制</button>
                         <button id="iframe-analysis-btn" class="btn-secondary">🔍 iframe分析</button>
                         <button id="batch-iframe-extract-btn" class="btn-secondary">📥 批量提取iframe</button>
                         <button id="direct-iframe-select-btn" class="btn-secondary">🎯 直选iframe</button>
                         <button id="ant-table-extract-btn" class="btn-secondary">🐜 Ant表格</button>
                         <button id="about-btn" class="btn-secondary">ℹ️ About</button>
                    </div>
                    <div id="status" class="status"></div>
                </div>
            `;

            console.log('创建工具栏HTML结构完成');

            // 确保body存在
            if (!document.body) {
                console.error('document.body 不存在，无法添加工具栏');
                return;
            }

            document.body.appendChild(toolbar);
            console.log('工具栏已添加到页面');

            // 验证工具栏是否成功添加
            const addedToolbar = document.getElementById(CONFIG.TOOLBAR_ID);
            if (addedToolbar) {
                console.log('✅ 工具栏添加成功');
                bindEvents();
                return true;
            } else {
                console.error('❌ 工具栏添加失败');
                return false;
            }
        } catch (error) {
            console.error('创建悬浮工具栏时出错:', error);
            return false;
        }
    }

    function addCustomStyles() {
        // 移除可能存在的旧样式
        const existingStyle = document.getElementById('md-extractor-styles');
        if (existingStyle) {
            existingStyle.remove();
        }

        const style = document.createElement('style');
        style.id = 'md-extractor-styles';
        style.textContent = `
            #${CONFIG.TOOLBAR_ID} {
                position: fixed !important;
                top: 20px;
                right: 20px;
                width: 240px !important;
                background: #fff !important;
                border: 1px solid #e0e0e0 !important;
                border-radius: 6px !important;
                box-shadow: 0 2px 8px rgba(0,0,0,0.08) !important;
                z-index: 999999 !important;
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif !important;
                font-size: 12px !important;
                color: #333 !important;
            }
            #${CONFIG.TOOLBAR_ID} .toolbar-header {
                background: #f9f9f9 !important;
                border-bottom: 1px solid #e5e5e5 !important;
                color: #333 !important;
                padding: 8px 12px !important;
                display: flex !important;
                justify-content: space-between !important;
                align-items: center !important;
                border-radius: 6px 6px 0 0 !important;
                cursor: move !important;
                font-weight: 500 !important;
                font-size: 11px !important;
            }
            #${CONFIG.TOOLBAR_ID} #toggle-btn {
                background: none !important;
                border: none !important;
                font-size: 14px !important;
                cursor: pointer !important;
                color: #888 !important;
                padding: 0 !important;
                width: 20px !important;
                height: 20px !important;
                line-height: 20px !important;
            }
            #${CONFIG.TOOLBAR_ID} .toolbar-content {
                padding: 10px !important;
            }
            #${CONFIG.TOOLBAR_ID} .toolbar-content.collapsed {
                display: none !important;
            }
            #${CONFIG.TOOLBAR_ID} .main-controls,
            #${CONFIG.TOOLBAR_ID} .action-buttons {
                display: grid !important;
                grid-template-columns: 1fr 1fr !important;
                gap: 6px !important;
                margin-bottom: 8px !important;
            }
            #${CONFIG.TOOLBAR_ID} .manual-actions {
                display: grid !important;
                grid-template-columns: 1fr 1fr !important;
                gap: 6px !important;
                margin-bottom: 8px !important;
            }
            #${CONFIG.TOOLBAR_ID} button {
                background-color: #fff !important;
                border: 1px solid #e0e0e0 !important;
                padding: 6px 8px !important;
                border-radius: 3px !important;
                cursor: pointer !important;
                font-weight: 400 !important;
                transition: all 0.15s !important;
                white-space: nowrap !important;
                color: #333 !important;
                font-size: 11px !important;
            }
            #${CONFIG.TOOLBAR_ID} button:hover {
                background-color: #f5f5f5 !important;
                border-color: #d0d0d0 !important;
            }
            #${CONFIG.TOOLBAR_ID} .btn-primary {
                background-color: #007bff !important;
                color: white !important;
                border-color: #007bff !important;
            }
            #${CONFIG.TOOLBAR_ID} .btn-primary:hover {
                background-color: #0069d9 !important;
                border-color: #0062cc !important;
            }
            #${CONFIG.TOOLBAR_ID} .btn-picker.picking {
                background-color: #dc3545 !important;
                color: white !important;
                border-color: #dc3545 !important;
            }
            #${CONFIG.TOOLBAR_ID} .btn-secondary {
                background-color: #6c757d !important;
                color: white !important;
                border-color: #6c757d !important;
            }
            #${CONFIG.TOOLBAR_ID} .btn-secondary:hover {
                background-color: #5a6268 !important;
                border-color: #545b62 !important;
            }
            #${CONFIG.TOOLBAR_ID} .selector-group {
                margin-bottom: 10px !important;
            }
            #${CONFIG.TOOLBAR_ID} label {
                font-size: 12px !important;
                color: #555 !important;
                margin-bottom: 5px !important;
                display: block !important;
            }
            #${CONFIG.TOOLBAR_ID} .options-group label {
                display: inline-flex !important;
                align-items: center !important;
                margin-right: 15px !important;
                font-weight: normal !important;
            }
            #${CONFIG.TOOLBAR_ID} input[type="text"] {
                width: 100% !important;
                padding: 6px !important;
                border: 1px solid #e0e0e0 !important;
                border-radius: 3px !important;
                box-sizing: border-box !important;
                font-family: 'SF Mono', 'Courier New', monospace !important;
                font-size: 11px !important;
                color: #333 !important;
            }
            #${CONFIG.TOOLBAR_ID} input[type="checkbox"] {
                margin-right: 5px !important;
            }
            #${CONFIG.TOOLBAR_ID} .status {
                padding: 6px !important;
                border-radius: 3px !important;
                font-size: 10px !important;
                text-align: center !important;
                min-height: 16px !important;
                margin-top: 6px !important;
            }
            #${CONFIG.TOOLBAR_ID} .status:empty {
                display: none !important;
            }
            #${CONFIG.TOOLBAR_ID} .status.success {
                background: #d4edda !important;
                color: #155724 !important;
            }
            #${CONFIG.TOOLBAR_ID} .status.error {
                background: #f8d7da !important;
                color: #721c24 !important;
            }
            #${CONFIG.TOOLBAR_ID} .status.info {
                background: #d1ecf1 !important;
                color: #0c5460 !important;
            }
            .${CONFIG.HIGHLIGHT_CLASS} {
                outline: 2px solid #dc3545 !important;
                background-color: rgba(220, 53, 69, 0.1) !important;
                transition: all 0.2s !important;
            }
            .${CONFIG.HOVER_HIGHLIGHT_CLASS} {
                outline: 2px dashed #007bff !important;
                background-color: rgba(0, 123, 255, 0.1) !important;
                cursor: crosshair !important;
            }
        `;
        document.head.appendChild(style);
    }

    // 处理来自父窗口的内容请求
    function handleContentRequest(event) {
        debugLog('处理内容请求，iframe ID:', event.data.iframeId);

        try {
            // 提取当前iframe的内容
            const content = extractContentFromDocument(document);

            // 发送内容回父窗口
            window.parent.postMessage({
                type: 'iframeContent',
                iframeId: event.data.iframeId,
                content: content,
                success: !!content
            }, '*');

            debugLog('已发送内容到父窗口，内容长度:', content ? content.length : 0);

        } catch (error) {
            debugLog('处理内容请求失败:', error.message);

            // 发送错误信息到父窗口
            window.parent.postMessage({
                type: 'iframeContent',
                iframeId: event.data.iframeId,
                content: null,
                success: false,
                error: error.message
            }, '*');
        }
    }

    // This is the single, consolidated bindEvents function
    function bindEvents() {
        const toggleBtn = document.getElementById('toggle-btn');
        const elementPickerBtn = document.getElementById('element-picker-btn');
        const autoDetectBtn = document.getElementById('auto-detect-btn');
        const extractBtn = document.getElementById('extract-btn');
        const previewBtn = document.getElementById('preview-btn');
        const manualCopyBtn = document.getElementById('manual-copy-btn');
        const exportHtmlBtn = document.getElementById('export-html-btn');
        const iframeAnalysisBtn = document.getElementById('iframe-analysis-btn');
        const batchIframeExtractBtn = document.getElementById('batch-iframe-extract-btn');
        const directIframeSelectBtn = document.getElementById('direct-iframe-select-btn');
        const antTableExtractBtn = document.getElementById('ant-table-extract-btn');
        const aboutBtn = document.getElementById('about-btn');
        const selectorInput = document.getElementById('selector-input');

        if (toggleBtn) {
            toggleBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                const content = document.querySelector(`#${CONFIG.TOOLBAR_ID} .toolbar-content`);
                if (content) {
                    content.classList.toggle('collapsed');
                    e.target.textContent = content.classList.contains('collapsed') ? '＋' : '－';
                }
            });
        }

        if (elementPickerBtn) {
            console.log('[Element Picker] 绑定选择器按钮事件');
            elementPickerBtn.addEventListener('click', (e) => {
                console.log('[Element Picker] 选择器按钮被点击');
                e.preventDefault();
                e.stopPropagation();
                togglePickingMode();
            });
        } else {
            console.warn('[Element Picker] 未找到选择器按钮');
        }

        if (autoDetectBtn) {
            autoDetectBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                autoDetectContent();
            });
        }

        if (extractBtn) {
            extractBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                extractAndCopy();
            });
        }

        if (previewBtn) {
            previewBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                previewContent();
            });
        }

        if (manualCopyBtn) {
            manualCopyBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                manualExtractAndCopy();
            });
        }

        if (exportHtmlBtn) {
            exportHtmlBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                handleExportHtml();
            });
        }

        if (iframeAnalysisBtn) {
            iframeAnalysisBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                performIframeAnalysis();
            });
        }

        if (batchIframeExtractBtn) {
            batchIframeExtractBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                performBatchIframeExtraction();
            });
        }

        if (directIframeSelectBtn) {
            directIframeSelectBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                directSelectIframe();
            });
        }

        if (antTableExtractBtn) {
            antTableExtractBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                extractAntTableDirectly();
            });
        }

        if (aboutBtn) {
            aboutBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                showAboutDialog();
            });
        }

        if (selectorInput) {
            // 防抖的输入处理
            let inputTimeout;
            selectorInput.addEventListener('input', (e) => {
                clearTimeout(inputTimeout);
                inputTimeout = setTimeout(() => {
                    const selector = e.target.value.trim();
                    if (selector) {
                        highlightElement(selector);
                    } else {
                        // 清除高亮
                        document.querySelectorAll(`.${CONFIG.HIGHLIGHT_CLASS}`).forEach(el => {
                            el.classList.remove(CONFIG.HIGHLIGHT_CLASS);
                        });
                    }
                }, 500); // 500ms防抖
            });

            // 回车键直接提取
            selectorInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    extractAndCopy();
                }
            });
        }

        makeDraggable();
    }


    // =================================================================================
    // --- 可视化选择核心 (Visual Picker Core) ---
    // =================================================================================
    function togglePickingMode() {
        console.log('[Element Picker] togglePickingMode 被调用，当前模式:', isPickingMode);
        if (isPickingMode) {
            exitPickingMode();
        } else {
            enterPickingMode();
        }
    }

    function enterPickingMode() {
        console.log('[Element Picker] 进入选择模式');
        isPickingMode = true;

        if (isTopWindow) {
            document.body.addEventListener('mouseover', handleMouseOver, true);
            document.body.addEventListener('click', handleMouseClick, true);
            document.addEventListener('keydown', handleKeyDown, true);

            // 通知所有 iframe 进入选择模式（级联传递）
            const iframes = document.querySelectorAll('iframe');
            debugLog(`发现${iframes.length}个iframe，开始发送enterPickingMode消息`);

            iframes.forEach((iframe, index) => {
                const iframeId = iframe.id || `iframe-${index}`;
                const iframeSrc = iframe.src || 'about:blank';

                // 检查是否是同源iframe
                let isSameOrigin = false;
                try {
                    const iframeDoc = iframe.contentDocument;
                    isSameOrigin = !!iframeDoc;
                } catch (e) {
                    isSameOrigin = false;
                }

                debugLog(`处理iframe: ${iframeId}, 同源: ${isSameOrigin}, src: ${iframeSrc}`);

                try {
                    // 尝试发送消息
                    iframe.contentWindow.postMessage({ type: 'enterPickingMode' }, '*');
                    debugLog(`✅ 已通知iframe ${iframeId} 进入选择模式`);

                    // 为iframe添加可视化边框
                    iframe.style.border = '2px dashed #007bff';
                    iframe.style.boxShadow = '0 0 10px rgba(0, 123, 255, 0.3)';
                    iframe.classList.add('md-extractor-iframe-active');

                    // 特殊处理：如果是特定的iframe（如mainIframe），添加额外标记
                    if (iframeId === 'mainIframe' || iframeId.includes('main')) {
                        iframe.setAttribute('data-md-main-iframe', 'true');
                        debugLog(`标记主iframe: ${iframeId}`);
                    }

                } catch (e) {
                    debugLog(`❌ 无法向iframe ${iframeId} 发送消息:`, e.message);

                    // 跨域iframe的备用处理
                    iframe.style.border = '2px dashed #ffc107';
                    iframe.style.boxShadow = '0 0 10px rgba(255, 193, 7, 0.3)';
                    iframe.classList.add('md-extractor-iframe-cross-origin');

                    // 如果是跨域iframe，尝试通过其他方式激活选择功能
                    handleCrossOriginIframe(iframe, iframeId);
                }
            });

            const pickerBtn = document.getElementById('element-picker-btn');
            if (pickerBtn) {
                pickerBtn.classList.add('picking');
                pickerBtn.textContent = '❌ 取消选择';
            }
            const iframeCount = iframes.length;
            if (iframeCount > 0) {
                showStatus(`进入选择模式：已激活${iframeCount}个iframe的选择功能。请点击任意区域选择元素。按 ESC 取消。`, 'info');
            } else {
                showStatus('进入选择模式：请点击您想提取的区域。按 ESC 取消。', 'info');
            }
        } else {
            // 在 iframe 中
            document.body.addEventListener('mouseover', handleMouseOver, true);
            document.body.addEventListener('click', handleMouseClick, true);
            document.addEventListener('keydown', handleKeyDown, true);
        }
    }

    // 处理跨域iframe的备用方案
    function handleCrossOriginIframe(iframe, iframeId) {
        debugLog(`处理跨域iframe: ${iframeId}`);

        // 方案1: 尝试延迟重试发送消息
        setTimeout(() => {
            try {
                iframe.contentWindow.postMessage({ type: 'enterPickingMode' }, '*');
                debugLog(`延迟重试成功: ${iframeId}`);

                // 更新边框颜色表示成功
                iframe.style.border = '2px dashed #28a745';
                iframe.style.boxShadow = '0 0 10px rgba(40, 167, 69, 0.3)';
                iframe.classList.remove('md-extractor-iframe-cross-origin');
                iframe.classList.add('md-extractor-iframe-active');

            } catch (e) {
                debugLog(`延迟重试失败: ${iframeId}`, e.message);

                // 方案2: 添加点击监听器到iframe本身
                addIframeClickListener(iframe, iframeId);
            }
        }, 500);
    }

    // 为无法通信的iframe添加点击监听器
    function addIframeClickListener(iframe, iframeId) {
        debugLog(`为iframe添加点击监听器: ${iframeId}`);

        // 在iframe上覆盖一个透明层，用于捕获点击事件
        const overlay = document.createElement('div');
        overlay.id = `md-iframe-overlay-${iframeId}`;
        overlay.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 123, 255, 0.1);
            z-index: 10000;
            cursor: crosshair;
            pointer-events: all;
        `;

        overlay.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();

            debugLog(`检测到iframe点击: ${iframeId}`);

            // 移除overlay并退出选择模式
            overlay.remove();
            exitPickingMode();

            // 尝试提取iframe内容
            extractIframeContent(iframe, iframeId);
        });

        // 设置iframe容器的相对定位
        const iframeContainer = iframe.parentElement;
        if (iframeContainer && getComputedStyle(iframeContainer).position === 'static') {
            iframeContainer.style.position = 'relative';
        }

        // 将overlay添加到iframe的父元素中
        if (iframe.parentElement) {
            iframe.parentElement.appendChild(overlay);
            debugLog(`已为iframe ${iframeId} 添加点击覆盖层`);
        }
    }

    // 提取iframe内容的核心函数
    async function extractIframeContent(iframe, iframeId) {
        debugLog(`开始提取iframe内容: ${iframeId}`);
        showStatus('正在尝试提取iframe内容...', 'info');

        try {
            // 方法1: 尝试直接访问iframe内容（同源）
            if (await tryDirectAccess(iframe, iframeId)) {
                return;
            }

            // 方法2: 尝试通过消息通信获取内容
            if (await tryMessageCommunication(iframe, iframeId)) {
                return;
            }

            // 方法3: 尝试从iframe源URL获取内容
            if (await tryUrlFetch(iframe, iframeId)) {
                return;
            }

            // 方法4: 备用方案 - 提供手动指导
            provideFallbackGuidance(iframe, iframeId);

        } catch (error) {
            debugLog('iframe内容提取失败:', error);
            showStatus('iframe内容提取失败，请尝试直接在iframe内使用脚本', 'error');
        }
    }

    // 方法1: 直接访问（同源iframe）
    async function tryDirectAccess(iframe, iframeId) {
        try {
            const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
            if (iframeDoc) {
                debugLog('成功直接访问iframe文档');

                // 直接在iframe文档中查找内容
                const content = extractContentFromDocument(iframeDoc);
                if (content) {
                    await copyToClipboard(content);
                    showStatus(`✅ 已从iframe "${iframeId}" 提取内容到剪贴板`, 'success');
                    return true;
                }
            }
        } catch (e) {
            debugLog('直接访问失败:', e.message);
        }
        return false;
    }

    // 方法2: 消息通信
    async function tryMessageCommunication(iframe, iframeId) {
        return new Promise((resolve) => {
            debugLog('尝试通过消息通信获取内容');

            const timeout = setTimeout(() => {
                debugLog('消息通信超时');
                resolve(false);
            }, 3000);

            // 监听iframe响应
            const messageHandler = (event) => {
                if (event.data.type === 'iframeContent' && event.data.iframeId === iframeId) {
                    clearTimeout(timeout);
                    window.removeEventListener('message', messageHandler);

                    if (event.data.content) {
                        copyToClipboard(event.data.content);
                        showStatus(`✅ 已通过通信从iframe "${iframeId}" 获取内容`, 'success');
                        resolve(true);
                    } else {
                        resolve(false);
                    }
                }
            };

            window.addEventListener('message', messageHandler);

            // 请求iframe发送内容
            try {
                iframe.contentWindow.postMessage({
                    type: 'requestContent',
                    iframeId: iframeId
                }, '*');
            } catch (e) {
                clearTimeout(timeout);
                window.removeEventListener('message', messageHandler);
                resolve(false);
            }
        });
    }

    // 方法3: URL获取
    async function tryUrlFetch(iframe, iframeId) {
        try {
            const iframeSrc = iframe.src;
            if (!iframeSrc || iframeSrc === 'about:blank') {
                return false;
            }

            debugLog('尝试从URL获取内容:', iframeSrc);

            // 检查是否同源
            const currentOrigin = window.location.origin;
            const iframeUrl = new URL(iframeSrc, window.location.href);

            if (iframeUrl.origin === currentOrigin) {
                const response = await fetch(iframeSrc);
                if (response.ok) {
                    const html = await response.text();
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');

                    const content = extractContentFromDocument(doc);
                    if (content) {
                        await copyToClipboard(content);
                        showStatus(`✅ 已从URL获取iframe "${iframeId}" 内容`, 'success');
                        return true;
                    }
                }
            }
        } catch (e) {
            debugLog('URL获取失败:', e.message);
        }
        return false;
    }

    // 方法4: 备用指导
    function provideFallbackGuidance(iframe, iframeId) {
        debugLog('提供智能备用指导方案');

        // 分析iframe特征，提供针对性建议
        const analysis = analyzeIframeForGuidance(iframe, iframeId);

        // 创建增强的指导弹窗
        const modal = createEnhancedGuidanceModal(analysis, iframe);
        document.body.appendChild(modal);

        showStatus(`iframe "${iframeId}" 需要手动处理，已显示智能操作指南`, 'info');
    }

    // 分析iframe特征，生成针对性指导
    function analyzeIframeForGuidance(iframe, iframeId) {
        const analysis = {
            id: iframeId,
            src: iframe.src || 'about:blank',
            dimensions: {
                width: iframe.offsetWidth,
                height: iframe.offsetHeight,
                visible: iframe.offsetParent !== null
            },
            srcAnalysis: null,
            recommendations: [],
            urgency: 'medium'
        };

        // 分析src URL
        if (iframe.src) {
            try {
                const url = new URL(iframe.src, window.location.href);
                analysis.srcAnalysis = {
                    origin: url.origin,
                    isSameOrigin: url.origin === window.location.origin,
                    protocol: url.protocol,
                    hostname: url.hostname,
                    pathname: url.pathname,
                    isDataUrl: url.protocol === 'data:',
                    isBlobUrl: url.protocol === 'blob:'
                };

                // 基于URL特征生成建议
                if (analysis.srcAnalysis.isSameOrigin) {
                    analysis.recommendations.push('🔄 同源iframe，建议联系技术人员检查iframe加载状态');
                    analysis.urgency = 'high';
                } else {
                    analysis.recommendations.push('🌐 跨域iframe，这是最常见的情况');
                    analysis.recommendations.push('📂 建议在新标签页中打开URL进行内容提取');
                }

                if (analysis.srcAnalysis.isDataUrl) {
                    analysis.recommendations.push('📄 数据URL iframe，内容已嵌入在URL中');
                    analysis.urgency = 'low';
                } else if (analysis.srcAnalysis.isBlobUrl) {
                    analysis.recommendations.push('💾 Blob URL iframe，内容可能是动态生成的');
                }

                // 检查常见的系统类型
                if (url.hostname.includes('sharepoint') || url.hostname.includes('office365')) {
                    analysis.recommendations.push('🏢 检测到SharePoint/Office365，建议使用官方导出功能');
                } else if (url.hostname.includes('google') && url.pathname.includes('docs')) {
                    analysis.recommendations.push('📝 检测到Google Docs，建议使用"文件→下载"功能');
                }

            } catch (e) {
                analysis.recommendations.push('❓ URL解析失败，可能是相对路径或特殊格式');
            }
        } else {
            analysis.recommendations.push('🚫 iframe没有src属性，可能是动态加载或空iframe');
            analysis.urgency = 'low';
        }

        // 基于尺寸分析
        if (!analysis.dimensions.visible) {
            analysis.recommendations.push('👁️ iframe不可见，可能是隐藏元素');
        } else if (analysis.dimensions.width < 100 || analysis.dimensions.height < 100) {
            analysis.recommendations.push('📏 iframe尺寸很小，可能不包含主要内容');
        }

        return analysis;
    }

    // 创建指导弹窗
    function createGuidanceModal(guidance, iframe) {
        const modal = document.createElement('div');
        modal.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border: 2px solid #007bff;
            border-radius: 8px;
            padding: 20px;
            z-index: 10001;
            max-width: 500px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        `;

        modal.innerHTML = `
            <h3>📋 iframe内容提取指南</h3>
            <pre style="white-space: pre-wrap; font-size: 12px; background: #f5f5f5; padding: 10px; border-radius: 4px;">${guidance}</pre>
            <div style="margin-top: 15px; text-align: right;">
                <button id="open-iframe-btn" style="margin-right: 10px; padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">在新页面打开</button>
                <button id="close-guidance-btn" style="padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">关闭</button>
            </div>
        `;

        // 绑定事件
        modal.querySelector('#close-guidance-btn').onclick = () => modal.remove();
        modal.querySelector('#open-iframe-btn').onclick = () => {
            if (iframe.src) {
                window.open(iframe.src, '_blank');
            }
            modal.remove();
        };

        return modal;
    }

    // 创建增强的指导弹窗
    function createEnhancedGuidanceModal(analysis, iframe) {
        const modal = document.createElement('div');
        modal.setAttribute('data-md-extractor-ui', 'true');
        modal.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border: 2px solid ${analysis.urgency === 'high' ? '#dc3545' : analysis.urgency === 'low' ? '#28a745' : '#007bff'};
            border-radius: 12px;
            padding: 0;
            z-index: 10001;
            max-width: 600px;
            max-height: 80vh;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        `;

        const urgencyColor = analysis.urgency === 'high' ? '#dc3545' :
                           analysis.urgency === 'low' ? '#28a745' : '#007bff';
        const urgencyText = analysis.urgency === 'high' ? '高优先级' :
                           analysis.urgency === 'low' ? '低优先级' : '中等优先级';

        modal.innerHTML = `
            <div style="background: ${urgencyColor}; color: white; padding: 16px 20px; border-radius: 10px 10px 0 0;">
                <h3 style="margin: 0; font-size: 18px; display: flex; align-items: center;">
                    🔍 iframe智能分析报告
                    <span style="margin-left: auto; font-size: 12px; background: rgba(255,255,255,0.2); padding: 4px 8px; border-radius: 12px;">${urgencyText}</span>
                </h3>
            </div>

            <div style="padding: 20px; max-height: 60vh; overflow-y: auto;">
                <div style="margin-bottom: 16px;">
                    <h4 style="margin: 0 0 8px 0; color: #333;">📋 基本信息</h4>
                    <div style="background: #f8f9fa; padding: 12px; border-radius: 6px; font-size: 13px;">
                        <div><strong>ID:</strong> ${analysis.id}</div>
                        <div><strong>URL:</strong> <span style="word-break: break-all;">${analysis.src}</span></div>
                        <div><strong>尺寸:</strong> ${analysis.dimensions.width}×${analysis.dimensions.height}px ${analysis.dimensions.visible ? '(可见)' : '(隐藏)'}</div>
                        ${analysis.srcAnalysis ? `
                        <div><strong>来源:</strong> ${analysis.srcAnalysis.hostname}</div>
                        <div><strong>类型:</strong> ${analysis.srcAnalysis.isSameOrigin ? '同源' : '跨域'}</div>
                        ` : ''}
                    </div>
                </div>

                <div style="margin-bottom: 16px;">
                    <h4 style="margin: 0 0 8px 0; color: #333;">💡 智能建议</h4>
                    <div style="background: #e8f5e8; padding: 12px; border-radius: 6px;">
                        ${analysis.recommendations.map(rec => `<div style="margin-bottom: 6px; font-size: 13px;">• ${rec}</div>`).join('')}
                    </div>
                </div>

                <div style="margin-bottom: 16px;">
                    <h4 style="margin: 0 0 8px 0; color: #333;">🛠️ 推荐操作</h4>
                    <div style="background: #fff3cd; padding: 12px; border-radius: 6px; font-size: 13px;">
                        ${generateActionSteps(analysis)}
                    </div>
                </div>
            </div>

            <div style="background: #f8f9fa; padding: 16px 20px; border-top: 1px solid #dee2e6; display: flex; justify-content: space-between; align-items: center;">
                <div style="font-size: 12px; color: #6c757d;">
                    ${analysis.srcAnalysis && analysis.srcAnalysis.isSameOrigin ? '⚠️ 同源iframe建议技术检查' : '🌐 跨域iframe需要新标签页处理'}
                </div>
                <div>
                    ${iframe.src ? '<button id="open-iframe-btn" style="margin-right: 8px; padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px;">🔗 新标签页打开</button>' : ''}
                    <button id="copy-url-btn" style="margin-right: 8px; padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px;">📋 复制URL</button>
                    <button id="close-guidance-btn" style="padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px;">关闭</button>
                </div>
            </div>
        `;

        // 绑定事件
        modal.querySelector('#close-guidance-btn').onclick = () => modal.remove();

        const openBtn = modal.querySelector('#open-iframe-btn');
        if (openBtn) {
            openBtn.onclick = () => {
                if (iframe.src) {
                    window.open(iframe.src, '_blank');
                    showStatus('已在新标签页中打开iframe', 'success');
                }
                modal.remove();
            };
        }

        const copyBtn = modal.querySelector('#copy-url-btn');
        if (copyBtn) {
            copyBtn.onclick = () => {
                if (iframe.src) {
                    navigator.clipboard.writeText(iframe.src).then(() => {
                        showStatus('URL已复制到剪贴板', 'success');
                        copyBtn.textContent = '✅ 已复制';
                        setTimeout(() => {
                            copyBtn.textContent = '📋 复制URL';
                        }, 2000);
                    }).catch(() => {
                        showStatus('复制失败，请手动复制', 'error');
                    });
                }
            };
        }

        return modal;
    }

    // 生成操作步骤
    function generateActionSteps(analysis) {
        let steps = [];

        if (analysis.srcAnalysis && !analysis.srcAnalysis.isSameOrigin) {
            steps.push('1. 右键点击iframe，选择"在新标签页中打开"');
            steps.push('2. 在新页面中安装并使用此Markdown提取脚本');
            steps.push('3. 使用脚本的"选择元素"功能提取需要的内容');
        } else if (analysis.srcAnalysis && analysis.srcAnalysis.isSameOrigin) {
            steps.push('1. 检查iframe是否完全加载');
            steps.push('2. 尝试刷新页面后重新提取');
            steps.push('3. 联系技术人员检查iframe配置');
        } else {
            steps.push('1. 检查iframe是否包含有效内容');
            steps.push('2. 查看浏览器控制台是否有错误信息');
            steps.push('3. 尝试刷新页面');
        }

        // 添加通用建议
        if (analysis.srcAnalysis && analysis.srcAnalysis.hostname) {
            if (analysis.srcAnalysis.hostname.includes('sharepoint')) {
                steps.push('4. 或使用SharePoint的"导出到Excel"功能');
            } else if (analysis.srcAnalysis.hostname.includes('google')) {
                steps.push('4. 或使用Google Docs的"下载"功能');
            }
        }

        return steps.map(step => `<div style="margin-bottom: 4px;">${step}</div>`).join('');
    }

    // 直接选择iframe功能
    async function directSelectIframe() {
        const iframes = document.querySelectorAll('iframe');

        if (iframes.length === 0) {
            showStatus('页面中没有发现iframe', 'error');
            return;
        }

        if (iframes.length === 1) {
            // 只有一个iframe，直接选择
            const iframe = iframes[0];
            const iframeId = iframe.id || 'iframe-0';
            showStatus(`发现1个iframe，正在尝试提取内容...`, 'info');

            // 设置选择器为iframe
            const selectorInput = document.getElementById('selector-input');
            if (selectorInput) {
                selectorInput.value = `iframe${iframe.id ? '#' + iframe.id : ''}`;
            }

            // 设置选择上下文
            selectionContext = {
                source: 'top',
                selector: `iframe${iframe.id ? '#' + iframe.id : ''}`,
                iframeId: null
            };

            // 高亮显示iframe
            highlightIframe(iframe);

            // 尝试提取内容
            await extractIframeContent(iframe, iframeId);

        } else {
            // 多个iframe，显示选择对话框
            showIframeSelectionDialog(iframes);
        }
    }

    // 显示iframe选择对话框
    function showIframeSelectionDialog(iframes) {
        const modal = document.createElement('div');
        modal.setAttribute('data-md-extractor-ui', 'true');
        modal.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border: 2px solid #007bff;
            border-radius: 12px;
            padding: 0;
            z-index: 10001;
            max-width: 700px;
            max-height: 80vh;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        `;

        let iframeListHtml = '';
        iframes.forEach((iframe, index) => {
            const id = iframe.id || `iframe-${index}`;
            const src = iframe.src || 'about:blank';
            const width = iframe.offsetWidth;
            const height = iframe.offsetHeight;
            const visible = iframe.offsetParent !== null;

            iframeListHtml += `
                <div style="border: 1px solid #dee2e6; border-radius: 6px; padding: 12px; margin-bottom: 8px; cursor: pointer; transition: all 0.2s;"
                     data-iframe-index="${index}" class="iframe-option"
                     onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background='white'">
                    <div style="font-weight: bold; color: #007bff; margin-bottom: 4px;">📱 ${id}</div>
                    <div style="font-size: 12px; color: #6c757d; margin-bottom: 4px; word-break: break-all;">
                        🌐 ${src.length > 60 ? src.substring(0, 60) + '...' : src}
                    </div>
                    <div style="font-size: 12px; color: #6c757d;">
                        📏 ${width}×${height}px ${visible ? '✅ 可见' : '❌ 隐藏'}
                    </div>
                </div>
            `;
        });

        modal.innerHTML = `
            <div style="background: #007bff; color: white; padding: 16px 20px; border-radius: 10px 10px 0 0;">
                <h3 style="margin: 0; font-size: 18px;">🎯 选择要提取的iframe</h3>
            </div>

            <div style="padding: 20px; max-height: 60vh; overflow-y: auto;">
                <div style="margin-bottom: 16px; color: #666; font-size: 14px;">
                    检测到${iframes.length}个iframe，请选择要提取内容的iframe：
                </div>
                ${iframeListHtml}
            </div>

            <div style="background: #f8f9fa; padding: 16px 20px; border-top: 1px solid #dee2e6; text-align: right;">
                <button id="cancel-iframe-select" style="padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px;">取消</button>
            </div>
        `;

        // 绑定事件
        modal.querySelector('#cancel-iframe-select').onclick = () => modal.remove();

        // 为每个iframe选项绑定点击事件
        modal.querySelectorAll('.iframe-option').forEach(option => {
            option.onclick = () => {
                const index = parseInt(option.dataset.iframeIndex);
                const iframe = iframes[index];

                modal.remove();

                // 在新标签页中打开iframe
                if (iframe.src) {
                    window.open(iframe.src, '_blank');
                } else {
                    showStatus('iframe没有有效的src地址', 'error');
                }
            };
        });

        document.body.appendChild(modal);
    }

    // 高亮显示iframe
    function highlightIframe(iframe) {
        // 清除之前的高亮
        document.querySelectorAll('.md-extractor-iframe-selected').forEach(el => {
            el.classList.remove('md-extractor-iframe-selected');
            el.style.border = '';
            el.style.boxShadow = '';
        });

        // 高亮当前iframe
        iframe.classList.add('md-extractor-iframe-selected');
        iframe.style.border = '3px solid #28a745';
        iframe.style.boxShadow = '0 0 20px rgba(40, 167, 69, 0.5)';

        // 3秒后清除高亮
        setTimeout(() => {
            iframe.style.border = '';
            iframe.style.boxShadow = '';
            iframe.classList.remove('md-extractor-iframe-selected');
        }, 3000);
    }

    // 直接提取Ant Design表格
    async function extractAntTableDirectly(selectedElement = null) {
        showStatus('正在搜索Ant Design表格...', 'info');

        try {
            // 优先在用户选择的容器内搜索，避免重复识别
            let tables = [];
            let sourceContext = '';

            if (selectedElement) {
                debugLog(`用户选择了容器: ${selectedElement.tagName}.${selectedElement.className}`);
                tables = findAntTables(document, selectedElement);
                sourceContext = `选择的容器(${selectedElement.tagName}.${selectedElement.className})`;
            } else {
                // 检查是否有用户当前选择的元素
                const selection = window.getSelection();
                if (selection.rangeCount > 0) {
                    const range = selection.getRangeAt(0);
                    const commonAncestor = range.commonAncestorContainer;
                    const selectedContainer = commonAncestor.nodeType === Node.ELEMENT_NODE ?
                                            commonAncestor : commonAncestor.parentElement;

                    if (selectedContainer && selectedContainer !== document.body) {
                        debugLog(`检测到用户选择: ${selectedContainer.tagName}.${selectedContainer.className}`);
                        tables = findAntTables(document, selectedContainer);
                        sourceContext = `选择的区域(${selectedContainer.tagName}.${selectedContainer.className})`;
                    }
                }

                // 如果没有选择或选择的容器内没有表格，则搜索整个页面
                if (tables.length === 0) {
                    tables = findAntTables(document);
                    sourceContext = '当前页面';
                }
            }

            // 如果当前页面没找到，搜索iframe
            if (tables.length === 0) {
                const iframes = document.querySelectorAll('iframe');
                for (let iframe of iframes) {
                    try {
                        const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                        if (iframeDoc) {
                            const iframeTables = findAntTables(iframeDoc);
                            if (iframeTables.length > 0) {
                                tables = iframeTables;
                                sourceContext = `iframe: ${iframe.id || 'unnamed'}`;
                                break;
                            }
                        }
                    } catch (e) {
                        debugLog(`无法访问iframe: ${iframe.id}`, e.message);
                    }
                }
            }

            if (tables.length === 0) {
                showStatus('未发现Ant Design表格结构', 'error');

                // 显示调试信息
                showAntTableDebugInfo();
                return;
            }

            showStatus(`在${sourceContext}发现${tables.length}个Ant表格，开始提取...`, 'info');

            if (tables.length === 1) {
                // 直接提取单个表格
                const result = await extractSingleAntTable(tables[0], sourceContext);
                if (result) {
                    openPreviewWindow(result, `Ant表格内容 - ${sourceContext}`);
                    showStatus('Ant表格提取完成！', 'success');
                }
            } else {
                // 多个表格，让用户选择
                showAntTableSelectionDialog(tables, sourceContext);
            }

        } catch (error) {
            showStatus(`Ant表格提取失败: ${error.message}`, 'error');
            console.error('Ant表格提取错误:', error);
        }
    }

    // 查找所有类型的表格（优先处理HUI，避免重复）
    function findAntTables(doc, containerElement = null) {
        const tables = [];
        const processedElements = new Set(); // 跟踪所有已处理的元素

        const searchScope = containerElement || doc;
        const scopeDesc = containerElement ? `容器(${containerElement.tagName}.${containerElement.className})` : 'document';
        debugLog(`=== 开始表格查找 (范围: ${scopeDesc}) ===`);

        // 第一步：使用更精确的策略查找HUI表格
        // 在指定范围内查找表头-表体配对，避免容器层级问题
        const headerDivs = searchScope.querySelectorAll('.h-table-header, .hui-table-header');
        debugLog(`在${scopeDesc}中找到${headerDivs.length}个HUI表头`);

        headerDivs.forEach((headerDiv, headerIndex) => {
            // 如果指定了容器，确保表头在容器内
            if (containerElement && !containerElement.contains(headerDiv)) {
                debugLog(`✗ 跳过容器外的表头 ${headerIndex + 1}`);
                return;
            }

            // 查找对应的表体（同级或附近）
            const parentContainer = headerDiv.parentElement;
            if (!parentContainer) return;

            const bodyDiv = parentContainer.querySelector('.h-table-body, .hui-table-body');
            if (!bodyDiv) return;

            // 如果指定了容器，确保表体也在容器内
            if (containerElement && !containerElement.contains(bodyDiv)) {
                debugLog(`✗ 跳过容器外的表体 ${headerIndex + 1}`);
                return;
            }

            const headerTable = headerDiv.querySelector('table');
            const bodyTable = bodyDiv.querySelector('table');

            if (headerTable && bodyTable) {
                // 检查是否已经处理过这个配对
                const uniqueKey = `${headerTable.outerHTML.substring(0, 100)}_${bodyTable.outerHTML.substring(0, 100)}`;
                if (processedElements.has(uniqueKey)) {
                    debugLog(`✗ 跳过重复的HUI表格配对 ${headerIndex + 1}`);
                    return;
                }

                // 标记为已处理
                processedElements.add(uniqueKey);
                processedElements.add(headerDiv);
                processedElements.add(bodyDiv);
                processedElements.add(headerTable);
                processedElements.add(bodyTable);
                processedElements.add(parentContainer);

                // 创建完整的HUI表格
                bodyTable._hTableHeader = headerTable;
                bodyTable._isHTableComplete = true;
                bodyTable._isHUITable = true;
                bodyTable._containerClass = parentContainer.className;
                bodyTable._uniqueKey = uniqueKey;

                tables.push(bodyTable);
                debugLog(`✓ 识别HUI完整表格 ${headerIndex + 1} (容器: ${parentContainer.className})`);
            }
        });

        // 第二步：处理Ant Design表格（严格避免HUI表格）
        debugLog('=== 开始查找Ant Design表格 ===');
        const antSelectors = [
            '.ant-table-body table',
            '.ant-table-fixed',
            '.ant-table-tbody',
            '.ant-table table',
            '[class*="ant-table"] table',
            'table[class*="ant-table"]',
            '.ant-table-container table'
        ];

        for (const selector of antSelectors) {
            const elements = searchScope.querySelectorAll(selector);
            elements.forEach((el, elIndex) => {
                // 如果指定了容器，确保元素在容器内
                if (containerElement && !containerElement.contains(el)) {
                    debugLog(`✗ 跳过容器外的元素: ${selector}[${elIndex}]`);
                    return;
                }
                // 检查1：跳过任何已处理的元素
                if (processedElements.has(el)) {
                    debugLog(`✗ 跳过已处理元素: ${selector}[${elIndex}]`);
                    return;
                }

                // 检查2：跳过HUI表格中的table元素
                const huiContainer = el.closest('.h-table-header, .h-table-body, .hui-table-header, .hui-table-body');
                if (huiContainer) {
                    debugLog(`✗ 跳过HUI表格内的table: ${selector}[${elIndex}]`);
                    processedElements.add(el); // 标记为已处理，避免后续重复检查
                    return;
                }

                // 检查3：跳过HUI容器内的任何元素
                if (el.closest('[class*="h-table"]')) {
                    debugLog(`✗ 跳过HUI容器内元素: ${selector}[${elIndex}]`);
                    processedElements.add(el);
                    return;
                }

                // 检查4：避免重复添加相同的表格
                if (tables.includes(el)) {
                    debugLog(`✗ 跳过重复表格: ${selector}[${elIndex}]`);
                    return;
                }

                tables.push(el);
                processedElements.add(el);
                debugLog(`✓ 发现Ant表格: ${selector}[${elIndex}] (class: ${el.className})`);
            });
        }

        debugLog(`表格查找完成: 找到${tables.length}个表格`);

        // 详细输出找到的表格信息和页面结构
        debugLog('=== 最终表格识别结果 ===');
        tables.forEach((table, index) => {
            const isHUI = table._isHUITable;
            const isComplete = table._isHTableComplete;
            const className = table.className;
            const containerClass = table._containerClass;
            const uniqueKey = table._uniqueKey ? table._uniqueKey.substring(0, 50) + '...' : 'N/A';

            debugLog(`表格${index + 1}:`);
            debugLog(`  - HUI表格: ${isHUI}`);
            debugLog(`  - 完整结构: ${isComplete}`);
            debugLog(`  - 表格class: "${className}"`);
            debugLog(`  - 容器class: "${containerClass}"`);
            debugLog(`  - 唯一标识: ${uniqueKey}`);
        });

        // 输出页面HUI结构概览
        debugLog('=== 页面HUI结构概览 ===');
        const allHuiElements = doc.querySelectorAll('[class*="h-table"]');
        debugLog(`总共找到 ${allHuiElements.length} 个HUI相关元素:`);
        allHuiElements.forEach((el, i) => {
            debugLog(`  ${i + 1}. ${el.tagName}.${el.className} (子元素: ${el.children.length})`);
        });

        return tables;
    }

    // 提取单个Ant表格
    async function extractSingleAntTable(table, sourceContext) {
        try {
            debugLog('开始分析表格结构...');

            // 检查是否为h-table结构
            if (table._isHTableComplete && table._hTableHeader) {
                return await extractHTableContent(table, sourceContext);
            }

            // 分析表格结构
            const analysis = analyzeAntTableStructure(table);
            debugLog('表格分析结果:', analysis);

            let markdown = `# Ant Design表格 - ${sourceContext}\n\n`;

            // 构建表头
            if (analysis.headers.length > 0) {
                markdown += '| ' + analysis.headers.join(' | ') + ' |\n';
                markdown += '| ' + analysis.headers.map(() => '---').join(' | ') + ' |\n';
            }

            // 提取表格数据
            const rows = table.querySelectorAll('tbody tr, tr');
            let dataRowCount = 0;

            rows.forEach((row, index) => {
                // 跳过表头行
                if (row.querySelector('th')) return;

                const cells = row.querySelectorAll('td');
                if (cells.length === 0) return;

                const rowData = [];

                cells.forEach((cell, cellIndex) => {
                    const cellContent = extractCellContent(cell, cellIndex, analysis);
                    rowData.push(cellContent);
                });

                if (rowData.some(content => content.trim().length > 0)) {
                    markdown += '| ' + rowData.join(' | ') + ' |\n';
                    dataRowCount++;
                }
            });

            // 添加统计信息
            if (dataRowCount > 0) {
                markdown += `\n**统计信息**:\n`;
                markdown += `- 数据行数: ${dataRowCount}\n`;
                markdown += `- 列数: ${analysis.headers.length || '未知'}\n`;
                markdown += `- 提取时间: ${new Date().toLocaleString()}\n`;

                // 分析内容类型
                const contentTypes = analyzeTableContentTypes(table);
                if (contentTypes.length > 0) {
                    markdown += `- 检测到的内容类型: ${contentTypes.join(', ')}\n`;
                }
            }

            return markdown;

        } catch (error) {
            debugLog('单表格提取错误:', error);
            return `提取失败: ${error.message}`;
        }
    }

    // 提取HUI/HUNDSUN h-table分离式表格内容
    async function extractHTableContent(bodyTable, sourceContext) {
        try {
            debugLog('开始提取HUI/HUNDSUN h-table分离式表格...');

            const headerTable = bodyTable._hTableHeader;
            const isHUITable = bodyTable._isHUITable;
            const containerClass = bodyTable._containerClass || '';

            let markdown = `# HUI表格 - ${sourceContext}\n\n`;
            if (containerClass) {
                markdown += `**表格类型**: ${containerClass}\n\n`;
            }

            // 从表头提取列标题 - 支持多种HUI表头结构
            const headers = [];
            const headerRows = headerTable.querySelectorAll('thead tr, tr');

            headerRows.forEach(row => {
                const headerCells = row.querySelectorAll('th');
                if (headerCells.length > 0) {
                    headerCells.forEach(cell => {
                        // HUI表格表头提取优化 - 支持多种选择器
                        const titleSelectors = [
                            '.span-cell',
                            '.h-table-head-title span',
                            '.h-table-head-title',
                            '.hui-table-head-title span',
                            '.hui-table-head-title',
                            '.h-table-cell-title'
                        ];

                        let headerText = '';
                        for (const selector of titleSelectors) {
                            const titleEl = cell.querySelector(selector);
                            if (titleEl) {
                                headerText = titleEl.textContent.trim();
                                break;
                            }
                        }

                        // 如果没找到特定选择器，使用cell内容
                        if (!headerText) {
                            headerText = cell.textContent.trim();
                        }

                        // 过滤隐藏列（与数据列过滤保持一致，保留序号列）
                        const hiddenClasses = ['h-table-hidden', 'hui-table-hidden', 'h-ui-t_base_selection_0'];
                        const isHidden = hiddenClasses.some(cls => cell.classList.contains(cls));

                        // 过滤规则与数据提取保持完全一致
                        if (!isHidden && headerText && headerText !== '选择') {
                            headers.push(headerText);
                            debugLog(`提取表头: "${headerText}" (class: ${cell.className})`);
                        } else {
                            debugLog(`跳过表头列: "${headerText}" (隐藏:${isHidden}, class: ${cell.className})`);
                        }
                    });
                }
            });

            // 如果没有从表头获取到标题，使用默认标题
            if (headers.length === 0) {
                const bodyRows = bodyTable.querySelectorAll('tbody tr, tr');
                if (bodyRows.length > 0) {
                    const firstRow = bodyRows[0];
                    const cells = firstRow.querySelectorAll('td');
                    for (let i = 0; i < cells.length; i++) {
                        if (!cells[i].classList.contains('h-table-hidden')) {
                            headers.push(`列${i + 1}`);
                        }
                    }
                }
            }

            debugLog(`h-table表头: ${headers.join(', ')}`);

            // 构建markdown表头
            if (headers.length > 0) {
                markdown += '| ' + headers.join(' | ') + ' |\n';
                markdown += '| ' + headers.map(() => '---').join(' | ') + ' |\n';
            }

            // 提取表体数据 - 优化HUI表格数据提取
            const bodyRows = bodyTable.querySelectorAll('tbody tr, tr');
            let dataRowCount = 0;

            bodyRows.forEach((row, index) => {
                const cells = row.querySelectorAll('td');
                if (cells.length === 0) return;

                const rowData = [];

                cells.forEach((cell, cellIndex) => {
                    // 跳过HUI隐藏列（保留序号列）
                    const hiddenClasses = ['h-table-hidden', 'hui-table-hidden', 'h-ui-t_base_selection_0'];
                    const isHidden = hiddenClasses.some(cls => cell.classList.contains(cls));
                    if (isHidden) {
                        debugLog(`跳过数据列: ${cellIndex} (${cell.className})`);
                        return;
                    }

                    let cellContent = '';

                    // HUI表格特有的内容提取优化
                    // 1. 处理业务链接内容（常见于金融业务系统）
                    const businessLink = cell.querySelector('a, .h-link, .hui-link');
                    if (businessLink) {
                        cellContent = businessLink.textContent.trim();
                    }
                    // 2. 处理HUI表格渲染器内容
                    else if (cell.querySelector('[columntype="huitablerender"]')) {
                        const renderDiv = cell.querySelector('[columntype="huitablerender"] div');
                        if (renderDiv) {
                            const linkInRender = renderDiv.querySelector('a');
                            cellContent = linkInRender ? linkInRender.textContent.trim() : renderDiv.textContent.trim();
                        }
                    }
                    // 3. 处理表格单元格内的span内容
                    else {
                        const contentSelectors = [
                            '.h-table-cell span',
                            '.hui-table-cell span',
                            '.span-cell',
                            'span',
                            '.h-table-cell',
                            '.hui-table-cell'
                        ];

                        for (const selector of contentSelectors) {
                            const contentEl = cell.querySelector(selector);
                            if (contentEl && contentEl.textContent.trim()) {
                                cellContent = contentEl.textContent.trim();
                                break;
                            }
                        }

                        // 如果还没找到内容，使用cell的直接文本
                        if (!cellContent) {
                            cellContent = cell.textContent.trim();
                        }
                    }

                    // 清理内容 - 移除多余空白和换行
                    cellContent = cellContent.replace(/\s+/g, ' ').trim();

                    // 处理金融业务常见的特殊字符
                    cellContent = cellContent.replace(/[\u200B-\u200D\uFEFF]/g, ''); // 移除零宽字符

                    rowData.push(cellContent);
                });

                if (rowData.some(content => content.length > 0)) {
                    markdown += '| ' + rowData.join(' | ') + ' |\n';
                    dataRowCount++;
                }
            });

            // 添加HUI表格统计信息
            if (dataRowCount > 0) {
                markdown += `\n**HUI表格统计信息**:\n`;
                markdown += `- 数据行数: ${dataRowCount}\n`;
                markdown += `- 列数: ${headers.length}\n`;
                markdown += `- 表格类型: HUI/HUNDSUN分离式结构\n`;
                markdown += `- 容器类名: ${containerClass}\n`;

                // 分析金融业务表格特征
                const businessFeatures = analyzeHUIBusinessFeatures(bodyTable, headerTable);
                if (businessFeatures.length > 0) {
                    markdown += `- 业务特征: ${businessFeatures.join(', ')}\n`;
                }

                markdown += `- 提取时间: ${new Date().toLocaleString()}\n`;
            }

            return markdown;

        } catch (error) {
            debugLog('HUI表格提取错误:', error);
            return `HUI表格提取失败: ${error.message}`;
        }
    }

    // 分析HUI表格业务特征
    function analyzeHUIBusinessFeatures(bodyTable, headerTable) {
        const features = [];

        try {
            // 检查表头特征
            if (headerTable) {
                const headerText = headerTable.textContent.toLowerCase();

                // 金融业务关键词检测
                if (headerText.includes('任务') || headerText.includes('流程')) {
                    features.push('工作流程表');
                }
                if (headerText.includes('审批') || headerText.includes('审核')) {
                    features.push('审批流表');
                }
                if (headerText.includes('投资') || headerText.includes('债权') || headerText.includes('信托')) {
                    features.push('投资业务表');
                }
                if (headerText.includes('处理人') || headerText.includes('当前节点')) {
                    features.push('节点处理表');
                }
            }

            // 检查表体特征
            if (bodyTable) {
                const bodyText = bodyTable.textContent.toLowerCase();

                // 检查是否包含金融产品名称模式
                if (/资管|信托/.test(bodyText)) {
                    features.push('金融产品列表');
                }

                // 检查是否包含任务ID模式
                if (/\d{8,}/.test(bodyText)) {
                    features.push('包含业务编号');
                }

                // 检查特殊组件
                if (bodyTable.querySelector('.h-checkbox, .hui-checkbox')) {
                    features.push('支持多选');
                }

                if (bodyTable.querySelector('[columntype="huitablerender"]')) {
                    features.push('自定义渲染器');
                }

                if (bodyTable.querySelector('.h-table-sort, .hui-table-sort')) {
                    features.push('支持排序');
                }

                // 检查分页信息
                const container = bodyTable.closest('[class*="h-table"], [class*="hui-table"]');
                if (container && container.querySelector('.h-pagination, .hui-pagination')) {
                    features.push('支持分页');
                }
            }

        } catch (error) {
            debugLog('HUI业务特征分析错误:', error);
        }

        return features;
    }

    // 分析Ant表格结构
    function analyzeAntTableStructure(table) {
        const analysis = {
            headers: [],
            columnCount: 0,
            hasCheckbox: false,
            hasActions: false,
            specialColumns: []
        };

        try {
            // 尝试从colgroup获取列信息
            const colgroup = table.querySelector('colgroup');
            if (colgroup) {
                const cols = colgroup.querySelectorAll('col');
                analysis.columnCount = cols.length;

                // 分析列特征
                cols.forEach((col, index) => {
                    const className = col.className;
                    if (className.includes('selection')) {
                        analysis.hasCheckbox = true;
                        analysis.specialColumns.push({ index, type: 'checkbox' });
                    }
                });
            }

            // 尝试从第一行数据推断列标题
            const firstDataRow = table.querySelector('tbody tr:first-child, tr:first-child');
            if (firstDataRow) {
                const cells = firstDataRow.querySelectorAll('td');

                cells.forEach((cell, index) => {
                    let header = '';

                    if (cell.classList.contains('ant-table-selection-column')) {
                        header = '选择';
                        analysis.hasCheckbox = true;
                    } else if (cell.querySelector('.subject-render, .subject-render-title')) {
                        header = '标题';
                    } else if (cell.querySelector('.current-nodes-column')) {
                        header = '当前处理人';
                    } else if (cell.querySelector('.category-label, .ant-tag')) {
                        header = '状态';
                    } else if (cell.textContent.trim().includes('刘煜洲')) {
                        header = '发起人';
                    } else {
                        header = `列${index + 1}`;
                    }

                    analysis.headers.push(header);
                });
            }

            // 如果没有推断出标题，使用默认标题
            if (analysis.headers.length === 0 && analysis.columnCount > 0) {
                for (let i = 0; i < analysis.columnCount; i++) {
                    analysis.headers.push(`列${i + 1}`);
                }
            }

        } catch (error) {
            debugLog('表格结构分析错误:', error);
        }

        return analysis;
    }

    // 提取单元格内容
    function extractCellContent(cell, cellIndex, analysis) {
        try {
            // 选择框列
            if (cell.classList.contains('ant-table-selection-column') ||
                cell.querySelector('input[type="checkbox"]')) {
                const checkbox = cell.querySelector('input[type="checkbox"]');
                return checkbox && checkbox.checked ? '☑ 已选择' : '☐ 未选择';
            }

            // 标题列 - 特殊处理
            const subjectTitle = cell.querySelector('.subject-render-title');
            if (subjectTitle) {
                let title = subjectTitle.textContent.trim();

                // 检查重要标记
                if (cell.querySelector('.xicon-important1, [class*="important"]')) {
                    title = '⭐ ' + title;
                }

                // 检查附件
                if (cell.querySelector('.attachment-color, [class*="attachment"]')) {
                    title += ' 📎';
                }

                return title;
            }

            // 当前处理人列
            const currentNode = cell.querySelector('.current-nodes-column');
            if (currentNode) {
                return currentNode.textContent.trim();
            }

            // 状态标签列
            const statusTag = cell.querySelector('.category-label .ant-tag, .ant-tag');
            if (statusTag) {
                return statusTag.textContent.trim();
            }

            // 一般列 - 清理文本
            let text = cell.textContent.trim();
            text = text.replace(/\s+/g, ' '); // 合并空白字符
            text = text.replace(/\n/g, ' '); // 替换换行

            return text || '-';

        } catch (error) {
            debugLog('单元格内容提取错误:', error);
            return cell.textContent.trim() || '-';
        }
    }

    // 分析表格内容类型 - 增强HUI/HUNDSUN组件支持
    function analyzeTableContentTypes(table) {
        const types = [];

        // 原有Ant Design组件检测
        if (table.querySelector('.subject-render, .subject-render-title')) {
            types.push('标题内容');
        }
        if (table.querySelector('.current-nodes-column')) {
            types.push('处理人信息');
        }
        if (table.querySelector('.category-label, .ant-tag')) {
            types.push('状态标签');
        }

        // HUI/HUNDSUN组件检测
        if (table.querySelector('.h-checkbox, .hui-checkbox, input[type="checkbox"]')) {
            types.push('选择框');
        }
        if (table.querySelector('.h-table-sort, .hui-table-sort')) {
            types.push('排序功能');
        }
        if (table.querySelector('[columntype="huitablerender"]')) {
            types.push('HUI自定义渲染');
        }
        if (table.querySelector('.h-link, .hui-link')) {
            types.push('业务链接');
        }
        if (table.querySelector('.h-table-cell-ellipsis, .hui-table-cell-ellipsis')) {
            types.push('文本省略');
        }

        // 金融业务特有标记
        if (table.querySelector('[class*="important"]')) {
            types.push('重要标记');
        }
        if (table.querySelector('[class*="attachment"]')) {
            types.push('附件标记');
        }
        if (table.querySelector('[class*="urgent"]')) {
            types.push('紧急标记');
        }

        // 业务流程相关
        if (table.querySelector('[class*="node"], [class*="workflow"]')) {
            types.push('流程节点');
        }
        if (table.querySelector('[class*="approval"], [class*="audit"]')) {
            types.push('审批状态');
        }

        // 通过内容文本判断业务类型
        const tableText = table.textContent.toLowerCase();
        if (/资管|信托|投资计划/.test(tableText)) {
            types.push('金融产品');
        }
        if (/审批|审核|待办|处理/.test(tableText)) {
            types.push('审批业务');
        }
        if (/\d{8,}/.test(tableText)) {
            types.push('业务编号');
        }

        return types;
    }

    // 显示Ant表格选择对话框
    function showAntTableSelectionDialog(tables, sourceContext) {
        const modal = document.createElement('div');
        modal.setAttribute('data-md-extractor-ui', 'true');
        modal.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border: 2px solid #1890ff;
            border-radius: 12px;
            padding: 0;
            z-index: 10001;
            max-width: 800px;
            max-height: 80vh;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        `;

        let tableListHtml = '';
        tables.forEach((table, index) => {
            const rowCount = table.querySelectorAll('tbody tr, tr').length;
            const colCount = table.querySelectorAll('tbody tr:first-child td, tr:first-child td').length;
            const hasCheckbox = !!table.querySelector('.ant-table-selection-column');
            const hasStatus = !!table.querySelector('.category-label, .ant-tag');

            tableListHtml += `
                <div style="border: 1px solid #d9d9d9; border-radius: 6px; padding: 16px; margin-bottom: 12px; cursor: pointer; transition: all 0.2s;"
                     data-table-index="${index}" class="table-option"
                     onmouseover="this.style.background='#f0f9ff'" onmouseout="this.style.background='white'">
                    <div style="font-weight: bold; color: #1890ff; margin-bottom: 8px; display: flex; align-items: center;">
                        🐜 表格 ${index + 1}
                        ${hasCheckbox ? '<span style="margin-left: 8px; background: #e6f7ff; color: #1890ff; padding: 2px 6px; border-radius: 4px; font-size: 12px;">选择框</span>' : ''}
                        ${hasStatus ? '<span style="margin-left: 8px; background: #f6ffed; color: #52c41a; padding: 2px 6px; border-radius: 4px; font-size: 12px;">状态标签</span>' : ''}
                    </div>
                    <div style="font-size: 13px; color: #666; margin-bottom: 4px;">
                        📊 ${rowCount} 行 × ${colCount} 列
                    </div>
                    <div style="font-size: 12px; color: #999;">
                        ${table.className || '无特殊样式类'}
                    </div>
                </div>
            `;
        });

        modal.innerHTML = `
            <div style="background: #1890ff; color: white; padding: 16px 20px; border-radius: 10px 10px 0 0;">
                <h3 style="margin: 0; font-size: 18px; display: flex; align-items: center;">
                    🐜 选择Ant Design表格
                    <span style="margin-left: auto; font-size: 12px; background: rgba(255,255,255,0.2); padding: 4px 8px; border-radius: 12px;">${sourceContext}</span>
                </h3>
            </div>

            <div style="padding: 20px; max-height: 60vh; overflow-y: auto;">
                <div style="margin-bottom: 16px; color: #666; font-size: 14px;">
                    在${sourceContext}发现${tables.length}个表格，请选择要提取的表格：
                </div>
                ${tableListHtml}
            </div>

            <div style="background: #fafafa; padding: 16px 20px; border-top: 1px solid #d9d9d9; text-align: right;">
                <button id="cancel-table-select" style="padding: 8px 16px; background: #d9d9d9; color: #666; border: none; border-radius: 4px; cursor: pointer; font-size: 13px;">取消</button>
            </div>
        `;

        // 绑定事件
        modal.querySelector('#cancel-table-select').onclick = () => modal.remove();

        // 为每个表格选项绑定点击事件
        modal.querySelectorAll('.table-option').forEach(option => {
            option.onclick = async () => {
                const index = parseInt(option.dataset.tableIndex);
                const table = tables[index];

                modal.remove();
                showStatus(`正在提取表格 ${index + 1}...`, 'info');

                const result = await extractSingleAntTable(table, `${sourceContext} - 表格${index + 1}`);
                if (result) {
                    openPreviewWindow(result, `Ant表格${index + 1} - ${sourceContext}`);
                    showStatus('表格提取完成！', 'success');
                }
            };
        });

        document.body.appendChild(modal);
    }

    // 显示Ant表格调试信息
    function showAntTableDebugInfo() {
        const debugInfo = `
=== Ant Design表格调试信息 ===

正在搜索的选择器:
- .ant-table-body table
- .ant-table-fixed
- .ant-table-tbody
- .ant-table table
- [class*="ant-table"] table
- table[class*="ant-table"]
- .ant-table-container table

当前页面发现的表格:
${Array.from(document.querySelectorAll('table')).map((table, i) =>
    `- 表格${i + 1}: ${table.className || '无class'} (${table.tagName})`
).join('\n')}

当前页面发现的Ant相关元素:
${Array.from(document.querySelectorAll('[class*="ant-table"]')).map((el, i) =>
    `- 元素${i + 1}: ${el.tagName} - ${el.className}`
).join('\n') || '无'}

建议:
1. 尝试使用"🎯 直选iframe"功能
2. 使用"🔍 iframe分析"查看iframe结构
3. 或手动输入选择器: .ant-table-body
        `;

        openPreviewWindow(debugInfo, 'Ant表格调试信息');
    }

    // 从文档中提取内容
    function extractContentFromDocument(doc) {
        try {
            // 首先尝试专门的表格内容提取
            const tableContent = extractTableContent(doc);
            if (tableContent && tableContent.trim().length > 100) {
                debugLog(`成功提取表格内容，长度: ${tableContent.length}`);
                return tableContent;
            }

            // 尝试找到主要内容区域
            const selectors = [
                '.ant-table-body', // Ant Design表格
                '.pending-list-main',
                '.main-content',
                '.content',
                'main',
                'article',
                '#main',
                'body'
            ];

            let content = '';
            for (const selector of selectors) {
                const element = doc.querySelector(selector);
                if (element) {
                    content = element.innerText || element.textContent;
                    if (content && content.trim().length > 50) {
                        debugLog(`成功从选择器 "${selector}" 提取内容，长度: ${content.length}`);
                        return content;
                    }
                }
            }

            // 如果没有找到特定区域，提取整个body
            const body = doc.body;
            if (body) {
                content = body.innerText || body.textContent;
                debugLog(`从body提取内容，长度: ${content.length}`);
                return content;
            }

        } catch (e) {
            debugLog('内容提取出错:', e.message);
        }
        return null;
    }

    // 专门的表格内容提取函数
    function extractTableContent(doc) {
        try {
            // 查找Ant Design表格
            const antTable = doc.querySelector('.ant-table-body table.ant-table-fixed');
            if (antTable) {
                return extractAntTableContent(antTable, doc);
            }

            // 查找普通表格
            const tables = doc.querySelectorAll('table');
            if (tables.length > 0) {
                return extractRegularTableContent(tables[0]);
            }

            return '';
        } catch (error) {
            debugLog('表格内容提取出错:', error);
            return '';
        }
    }

    // 提取Ant Design表格内容
    function extractAntTableContent(table, doc) {
        let markdown = '';

        try {
            // 获取表头信息（从colgroup推断）
            const colgroup = table.querySelector('colgroup');
            const cols = colgroup ? colgroup.querySelectorAll('col') : [];
            const columnCount = cols.length;

            // 推断列标题
            const headers = ['选择', '标题', '当前处理人', '发起人', '状态'];

            // 生成表头
            markdown += '| ' + headers.slice(0, columnCount).join(' | ') + ' |\n';
            markdown += '| ' + headers.slice(0, columnCount).map(() => '---').join(' | ') + ' |\n';

            // 提取表格行数据
            const rows = table.querySelectorAll('tbody tr.ant-table-row');
            debugLog(`找到${rows.length}行数据`);

            rows.forEach((row, index) => {
                const cells = row.querySelectorAll('td');
                const rowData = [];

                cells.forEach((cell, cellIndex) => {
                    let cellText = '';

                    if (cellIndex === 0) {
                        // 选择框列
                        cellText = '☐';
                    } else if (cell.querySelector('.subject-render-title')) {
                        // 标题列
                        const titleElement = cell.querySelector('.subject-render-title');
                        cellText = titleElement ? titleElement.textContent.trim() : '';

                        // 检查是否有重要标记
                        if (cell.querySelector('.xicon-important1')) {
                            cellText = '⭐ ' + cellText;
                        }

                        // 检查是否有附件
                        if (cell.querySelector('.attachment-color')) {
                            cellText += ' 📎';
                        }
                    } else if (cell.querySelector('.current-nodes-column')) {
                        // 当前处理人列
                        const nodeElement = cell.querySelector('.current-nodes-column');
                        cellText = nodeElement ? nodeElement.textContent.trim() : '';
                    } else if (cell.querySelector('.category-label .ant-tag')) {
                        // 状态标签列
                        const tagElement = cell.querySelector('.category-label .ant-tag');
                        cellText = tagElement ? tagElement.textContent.trim() : '';
                    } else {
                        // 其他列
                        cellText = cell.textContent.trim();
                    }

                    // 清理文本
                    cellText = cellText.replace(/\s+/g, ' ').trim();
                    rowData.push(cellText || '-');
                });

                // 只添加有内容的行
                if (rowData.some(cell => cell !== '-' && cell !== '☐')) {
                    markdown += '| ' + rowData.join(' | ') + ' |\n';
                }
            });

            // 添加统计信息
            if (rows.length > 0) {
                markdown += `\n**统计**: 共 ${rows.length} 条待办事项\n`;

                // 分析状态分布
                const statusMap = {};
                rows.forEach(row => {
                    const statusCell = row.querySelector('.category-label .ant-tag');
                    if (statusCell) {
                        const status = statusCell.textContent.trim();
                        statusMap[status] = (statusMap[status] || 0) + 1;
                    }
                });

                if (Object.keys(statusMap).length > 0) {
                    markdown += '\n**状态分布**:\n';
                    Object.entries(statusMap).forEach(([status, count]) => {
                        markdown += `- ${status}: ${count}条\n`;
                    });
                }
            }

            return markdown;

        } catch (error) {
            debugLog('Ant表格提取出错:', error);
            // 降级为普通文本提取
            return table.textContent || '';
        }
    }

    // 提取普通表格内容
    function extractRegularTableContent(table) {
        let markdown = '';

        try {
            const rows = table.querySelectorAll('tr');

            rows.forEach((row, index) => {
                const cells = row.querySelectorAll('th, td');
                const cellTexts = Array.from(cells).map(cell => {
                    return cell.textContent.trim().replace(/\s+/g, ' ');
                });

                if (cellTexts.some(text => text.length > 0)) {
                    markdown += '| ' + cellTexts.join(' | ') + ' |\n';

                    // 如果是第一行，添加分隔符
                    if (index === 0) {
                        markdown += '| ' + cellTexts.map(() => '---').join(' | ') + ' |\n';
                    }
                }
            });

            return markdown;

        } catch (error) {
            debugLog('普通表格提取出错:', error);
            return table.textContent || '';
        }
    }

    function exitPickingMode() {
        isPickingMode = false;

        if (isTopWindow) {
            document.body.removeEventListener('mouseover', handleMouseOver, true);
            document.body.removeEventListener('click', handleMouseClick, true);
            document.removeEventListener('keydown', handleKeyDown, true);

             // 通知所有 iframe 退出选择模式，并清除视觉效果
            document.querySelectorAll('iframe').forEach(iframe => {
                try {
                    iframe.contentWindow.postMessage({ type: 'exitPickingMode' }, '*');
                } catch (e) {
                    debugLog('通知iframe退出选择模式失败:', e.message);
                }

                // 清除iframe的视觉边框和覆盖层
                iframe.style.border = '';
                iframe.style.boxShadow = '';
                iframe.classList.remove('md-extractor-iframe-active', 'md-extractor-iframe-cross-origin');

                // 移除可能存在的覆盖层
                const iframeId = iframe.id || 'unknown';
                const overlay = document.getElementById(`md-iframe-overlay-${iframeId}`);
                if (overlay) {
                    overlay.remove();
                    debugLog(`已移除iframe覆盖层: ${iframeId}`);
                }
            });

            if (lastHoveredElement) {
                lastHoveredElement.classList.remove(CONFIG.HOVER_HIGHLIGHT_CLASS);
                lastHoveredElement = null;
            }

            const pickerBtn = document.getElementById('element-picker-btn');
            if (pickerBtn) {
                pickerBtn.classList.remove('picking');
                pickerBtn.textContent = '🖱️ 选择元素';
            }
            showStatus('已退出选择模式。', 'info');

        } else {
            // 在 iframe 中
            document.body.removeEventListener('mouseover', handleMouseOver, true);
            document.body.removeEventListener('click', handleMouseClick, true);
            document.removeEventListener('keydown', handleKeyDown, true);

            if (lastHoveredElement) {
                lastHoveredElement.classList.remove(CONFIG.HOVER_HIGHLIGHT_CLASS);
                lastHoveredElement = null;
            }
        }
    }

    function handleMouseOver(event) {
        if (!isPickingMode) return;

        let target = event.target;

        // 跳过工具栏和脚本生成的元素
        if (target.closest(`#${CONFIG.TOOLBAR_ID}`) ||
            target.closest('[data-md-extractor-ui]') ||
            target.id?.includes('md-iframe-overlay')) {
            return;
        }

        // 如果目标元素太小或不可见，尝试找到更合适的父元素
        const rect = target.getBoundingClientRect();
        if (rect.width < 10 || rect.height < 10) {
            let parent = target.parentElement;
            while (parent && parent !== document.body) {
                const parentRect = parent.getBoundingClientRect();
                if (parentRect.width >= 20 && parentRect.height >= 20) {
                    target = parent;
                    break;
                }
                parent = parent.parentElement;
            }
        }

        if (target === lastHoveredElement) return;

        if (lastHoveredElement) {
            lastHoveredElement.classList.remove(CONFIG.HOVER_HIGHLIGHT_CLASS);
        }

        target.classList.add(CONFIG.HOVER_HIGHLIGHT_CLASS);
        lastHoveredElement = target;

        debugLog('悬停元素:', {
            tagName: target.tagName,
            className: target.className,
            id: target.id,
            size: `${rect.width}x${rect.height}`
        });
    }

    function handleMouseClick(event) {
        if (!isPickingMode) return;

        // 检查是否点击了工具栏或脚本UI
        if (event.target.closest(`#${CONFIG.TOOLBAR_ID}`) ||
            event.target.closest('[data-md-extractor-ui]') ||
            event.target.id?.includes('md-iframe-overlay')) {
            return;
        }

        event.preventDefault();
        event.stopPropagation();

        try {
            let targetElement = event.target;

            debugLog('原始点击目标:', {
                tagName: targetElement.tagName,
                className: targetElement.className,
                id: targetElement.id
            });

            // 如果点击的是很小的元素或伪元素，尝试找到更合适的父元素
            const rect = targetElement.getBoundingClientRect();
            if (rect.width < 5 || rect.height < 5 ||
                targetElement.tagName === 'I' ||
                targetElement.tagName === 'SPAN' && rect.width < 20) {

                let parent = targetElement.parentElement;
                while (parent && parent !== document.body) {
                    const parentRect = parent.getBoundingClientRect();
                    if (parentRect.width >= 30 && parentRect.height >= 20) {
                        debugLog('调整目标元素从', targetElement.tagName, '到', parent.tagName);
                        targetElement = parent;
                        break;
                    }
                    parent = parent.parentElement;
                }
            }
            const selectors = generateAllSelectors(targetElement);
            let workingSelector = null;
            let bestScore = -1;

            // 测试所有选择器并选择最佳的
            const validSelectors = [];
            for (const selector of selectors) {
                if (testSelector(selector, targetElement)) {
                    const score = selector.score || 0;
                    validSelectors.push({ selector, score });
                    if (score > bestScore) {
                        bestScore = score;
                        workingSelector = selector;
                    }
                }
            }

            console.log(`找到${validSelectors.length}个有效选择器，最佳分数:${bestScore}`);

            // 如果找到多个选择器，优先选择OA系统特征的选择器
            if (validSelectors.length > 1) {
                const oaOptimizedSelector = optimizeForOASystem(validSelectors, targetElement);
                if (oaOptimizedSelector) {
                    workingSelector = oaOptimizedSelector;
                    console.log(`应用OA系统优化，选择器: ${workingSelector}`);
                }
            }

            // 如果没有找到有效的选择器，尝试使用第一个能匹配到目标元素的选择器
            if (!workingSelector) {
                for (const selector of selectors) {
                    try {
                        const found = document.querySelector(selector);
                        if (found === targetElement) {
                            workingSelector = selector;
                            break;
                        }
                    } catch (e) {
                        // 忽略无效选择器
                    }
                }
            }

            // 备用方案: 如果没有找到有效选择器，使用备用生成器
            if (!workingSelector) {
                debugLog('常规选择器生成失败，尝试备用方案');
                workingSelector = generateFallbackSelector(targetElement);
                if (workingSelector) {
                    debugLog('备用选择器生成成功:', workingSelector);
                    if (isTopWindow) {
                        showStatus('使用备用选择器成功选择元素', 'warning');
                    }
                    // 验证备用选择器
                    try {
                        const found = document.querySelector(workingSelector);
                        if (found !== targetElement) {
                            debugLog('备用选择器验证失败，匹配到错误元素');
                            workingSelector = null;
                        }
                    } catch (e) {
                        debugLog('备用选择器验证出错:', e);
                        workingSelector = null;
                    }
                }
            }

            if (!workingSelector) {
                 if (isTopWindow) {
                    showStatus('无法生成有效的选择器，请尝试其他元素', 'error');
                } else {
                    window.top.postMessage({ type: 'selectorError', message: '无法生成有效的选择器' }, '*');
                }
                return;
            }

            if (isTopWindow) {
                selectionContext = { source: 'top', selector: workingSelector, iframeId: null };
                const selectorInput = document.getElementById('selector-input');
                if (selectorInput) {
                    selectorInput.value = workingSelector;
                }
                highlightElement(workingSelector);
                console.log('[MD Extractor] 顶层窗口选择元素:', workingSelector);
                showStatus('已选择元素！', 'success');
            } else {
                // 在 iframe 中，将选择器发送到顶层窗口
                const myId = window.frameElement ? window.frameElement.id : null;
                const frameUrl = window.location.href;
                const isNestedFrame = window.parent !== window.top;

                console.log('[MD Extractor] iframe选择元素:', {
                    selector: workingSelector,
                    iframeId: myId,
                    url: frameUrl,
                    isNested: isNestedFrame,
                    frameElement: window.frameElement
                });

                if (!myId) {
                    window.top.postMessage({ type: 'selectorError', message: 'iframe缺少ID，无法选择' }, '*');
                    console.error('MD Extractor: iframe has no ID, cannot report selection.');
                    exitPickingMode();
                    return;
                }
                window.top.postMessage({ type: 'elementSelected', selector: workingSelector, iframeId: myId }, '*');
            }

            // 清理临时属性
            cleanupTemporaryAttributes(targetElement);

            exitPickingMode();

        } catch (error) {
             if (isTopWindow) {
                showStatus('选择元素失败：' + error.message, 'error');
            } else {
                window.top.postMessage({ type: 'selectorError', message: '选择元素失败：' + error.message }, '*');
            }
            console.error('选择元素失败:', error);
        }
    }

    // 生成所有可能的选择器（基于v5.9逻辑）
    // 增强选择器生成 - 特别优化div元素
    function generateAllSelectors(el) {
        const selectors = [];

        try {
            debugLog('为元素生成选择器:', el.tagName, el.className, el.id);

            // 1. ID选择器（最可靠）
            if (el.id && !el.id.includes('toolbar') && !el.id.includes('md-extractor')) {
                selectors.push(`#${CSS.escape(el.id)}`);
                debugLog('添加ID选择器:', `#${el.id}`);
            }

            // 2. 智能类名选择器（特别针对div）
            if (el.className) {
                const classList = Array.from(el.classList).filter(cls =>
                    cls.length > 1 &&
                    !cls.includes('hover') &&
                    !cls.includes('active') &&
                    !cls.includes('md-extractor') &&
                    !cls.includes('highlight')
                );

                // 优先处理有意义的类名
                const meaningfulClasses = classList.filter(cls =>
                    cls.includes('content') ||
                    cls.includes('item') ||
                    cls.includes('row') ||
                    cls.includes('cell') ||
                    cls.includes('container') ||
                    cls.includes('wrapper') ||
                    cls.includes('main') ||
                    cls.includes('list') ||
                    cls.includes('table') ||
                    cls.includes('card') ||
                    cls.includes('panel')
                );

                // 先尝试有意义的类名
                for (const cls of meaningfulClasses.slice(0, 2)) {
                    selectors.push(`.${CSS.escape(cls)}`);
                    debugLog('添加有意义类名选择器:', `.${cls}`);
                }

                // 再尝试其他类名
                for (const cls of classList.slice(0, 3)) {
                    if (!meaningfulClasses.includes(cls)) {
                        selectors.push(`.${CSS.escape(cls)}`);
                        debugLog('添加普通类名选择器:', `.${cls}`);
                    }
                }

                // 组合类名（最多2个有意义的）
                if (meaningfulClasses.length >= 2) {
                    const combo = meaningfulClasses.slice(0, 2).map(cls => `.${CSS.escape(cls)}`).join('');
                    selectors.push(combo);
                    debugLog('添加组合类名选择器:', combo);
                } else if (classList.length >= 2) {
                    const combo = classList.slice(0, 2).map(cls => `.${CSS.escape(cls)}`).join('');
                    selectors.push(combo);
                    debugLog('添加组合类名选择器:', combo);
                }
            }

            // 3. 扩展属性选择器
            const attrs = ['data-key', 'data-row-key', 'data-id', 'data-index', 'title', 'role', 'aria-label'];
            for (const attr of attrs) {
                const value = el.getAttribute(attr);
                if (value && value.length < 50 && value.trim()) {
                    selectors.push(`[${attr}="${CSS.escape(value)}"]`);
                    debugLog('添加属性选择器:', `[${attr}="${value}"]`);
                }
            }

            // 4. 增强位置选择器
            const parent = el.parentElement;
            if (parent) {
                const siblings = Array.from(parent.children);
                const index = siblings.indexOf(el);

                if (index >= 0) {
                    // 基本nth-child
                    selectors.push(`${el.tagName.toLowerCase()}:nth-child(${index + 1})`);

                    // 如果父元素有类名，添加更精确的选择器
                    if (parent.className) {
                        const parentClass = Array.from(parent.classList)[0];
                        if (parentClass && !parentClass.includes('md-extractor')) {
                            selectors.push(`.${CSS.escape(parentClass)} > ${el.tagName.toLowerCase()}:nth-child(${index + 1})`);
                            debugLog('添加父类+位置选择器:', `.${parentClass} > ${el.tagName.toLowerCase()}:nth-child(${index + 1})`);
                        }
                    }
                }
            }

            // 5. 内容相关选择器（针对div）
            if (el.tagName === 'DIV') {
                const text = el.textContent?.trim();
                if (text && text.length > 0 && text.length < 50) {
                    // 避免特殊字符
                    const cleanText = text.replace(/[^\w\s\u4e00-\u9fff]/g, '').trim();
                    if (cleanText.length > 0 && cleanText.length < 30) {
                        selectors.push(`div:contains("${cleanText}")`);
                        debugLog('添加内容选择器:', `div:contains("${cleanText}")`);
                    }
                }
            }

            // 6. 最基本的标签选择器
            selectors.push(el.tagName.toLowerCase());

        } catch (e) {
            debugLog('选择器生成失败:', e);
            selectors.push(el.tagName.toLowerCase());
        }

        const uniqueSelectors = [...new Set(selectors)];
        debugLog('生成的选择器列表:', uniqueSelectors);
        return uniqueSelectors;
    }

    // 清理临时属性
    function cleanupTemporaryAttributes(el) {
        if (!el) return;

        try {
            // 清理可能被添加的临时属性
            const tempAttrs = ['data-text', 'data-temp-id', 'data-emergency'];
            tempAttrs.forEach(attr => {
                if (el.hasAttribute(attr)) {
                    el.removeAttribute(attr);
                    debugLog('清理临时属性:', attr);
                }
            });
        } catch (e) {
            debugLog('清理临时属性失败:', e);
        }
    }

    // 备用选择器生成器 - 最简单但可靠的方案
    function generateFallbackSelector(el) {
        debugLog('生成备用选择器 for:', el.tagName, el.className);

        try {
            // 方案1: 尝试使用最基本的路径
            const path = [];
            let current = el;
            let depth = 0;

            while (current && current !== document.body && depth < 10) {
                const tagName = current.tagName.toLowerCase();
                const parent = current.parentElement;

                if (parent) {
                    const siblings = Array.from(parent.children).filter(child =>
                        child.tagName.toLowerCase() === tagName
                    );

                    if (siblings.length === 1) {
                        // 如果是唯一的该类型标签，直接使用标签名
                        path.unshift(tagName);
                    } else {
                        // 使用位置索引
                        const index = siblings.indexOf(current) + 1;
                        path.unshift(`${tagName}:nth-of-type(${index})`);
                    }
                } else {
                    path.unshift(tagName);
                }

                current = parent;
                depth++;
            }

            const pathSelector = path.join(' > ');
            debugLog('生成路径选择器:', pathSelector);

            // 验证选择器
            try {
                const found = document.querySelector(pathSelector);
                if (found === el) {
                    debugLog('路径选择器验证成功');
                    return pathSelector;
                }
            } catch (e) {
                debugLog('路径选择器验证失败:', e);
            }

            // 方案2: 使用位置 + 文本内容
            if (el.textContent && el.textContent.trim()) {
                const text = el.textContent.trim().substring(0, 20);
                const cleanText = text.replace(/[^\w\s\u4e00-\u9fff]/g, '').trim();
                if (cleanText.length > 0) {
                    const contentSelector = `${el.tagName.toLowerCase()}[data-text*="${cleanText}"]`;
                    // 临时添加属性用于选择
                    el.setAttribute('data-text', cleanText);
                    debugLog('生成内容选择器:', contentSelector);
                    return contentSelector;
                }
            }

            // 方案3: 使用相对位置
            const parent = el.parentElement;
            if (parent) {
                const allSiblings = Array.from(parent.children);
                const index = allSiblings.indexOf(el);
                if (index >= 0) {
                    const positionSelector = `${parent.tagName.toLowerCase()} > *:nth-child(${index + 1})`;
                    debugLog('生成位置选择器:', positionSelector);
                    return positionSelector;
                }
            }

            // 方案4: 最后的兜底方案 - 使用唯一的临时ID
            const fallbackId = 'temp-selector-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
            el.setAttribute('data-temp-id', fallbackId);
            const tempSelector = `[data-temp-id="${fallbackId}"]`;
            debugLog('生成临时ID选择器:', tempSelector);
            return tempSelector;

        } catch (e) {
            debugLog('备用选择器生成失败:', e);
            // 最终兜底
            const emergencyId = 'emergency-' + Date.now();
            el.setAttribute('data-emergency', emergencyId);
            return `[data-emergency="${emergencyId}"]`;
        }
    }

    // 智能类名选择器生成 - 针对OA系统优化
    function generateSmartClassSelector(el) {
        if (!el.className) return null;

        const classes = Array.from(el.classList).filter(cls => {
            // 过滤掉临时类和通用类
            return !cls.includes('hover') &&
                   !cls.includes('highlight') &&
                   !cls.includes('md-extractor') &&
                   !cls.includes('active') &&
                   !cls.includes('focus') &&
                   !cls.includes('selected') &&
                   cls.length > 1;
        });

        if (classes.length === 0) return null;

        // OA系统特有的高优先级类名
        const oaPriorityClasses = classes.filter(cls =>
            cls.includes('pending') ||
            cls.includes('list') ||
            cls.includes('table') ||
            cls.includes('content') ||
            cls.includes('main') ||
            cls.includes('body')
        );

        // Ant Design组件类名 (中等优先级)
        const antdClasses = classes.filter(cls => cls.startsWith('ant-'));

        // 业务相关类名 (高优先级)
        const businessClasses = classes.filter(cls =>
            !cls.startsWith('ant-') &&
            !cls.includes('icon') &&
            !cls.includes('btn') &&
            cls.length > 3
        );

        // 按优先级尝试选择器
        const prioritizedClasses = [
            ...oaPriorityClasses,
            ...businessClasses,
            ...antdClasses.slice(0, 3) // 只取前3个ant类，避免过长
        ];

        // 尝试单个类名
        for (const cls of prioritizedClasses) {
            const selector = `.${CSS.escape(cls)}`;
            const matches = document.querySelectorAll(selector);
            if (matches.length === 1 && matches[0] === el) {
                return selector;
            }
        }

        // 尝试有意义的类名组合
        if (prioritizedClasses.length > 1) {
            // 先尝试业务类+表结构类的组合
            const meaningfulCombos = [
                oaPriorityClasses.slice(0, 2),
                businessClasses.slice(0, 2),
                [...oaPriorityClasses.slice(0, 1), ...antdClasses.slice(0, 1)]
            ].filter(combo => combo.length > 0);

            for (const combo of meaningfulCombos) {
                const combinedSelector = combo.map(cls => `.${CSS.escape(cls)}`).join('');
                const matches = document.querySelectorAll(combinedSelector);
                if (matches.length >= 1 && matches.length <= 5 && Array.from(matches).includes(el)) {
                    return combinedSelector;
                }
            }
        }

        return null;
    }

    // OA系统选择器优化函数
    function optimizeForOASystem(validSelectors, targetElement) {
        // 按OA系统重要性排序选择器
        const scoredSelectors = validSelectors.map(({ selector, score }) => {
            let oaScore = score;

            // 业务优先级加分
            if (selector.includes('pending')) oaScore += 50;
            if (selector.includes('list-main')) oaScore += 40;
            if (selector.includes('table-body')) oaScore += 35;
            if (selector.includes('content')) oaScore += 30;

            // Ant Design组件加分
            if (selector.includes('ant-table-row')) oaScore += 25;
            if (selector.includes('ant-table-cell')) oaScore += 20;
            if (selector.includes('ant-list-item')) oaScore += 20;

            // 属性选择器加分
            if (selector.includes('[fiber-id=')) oaScore += 15;
            if (selector.includes('[data-row-key=')) oaScore += 15;
            if (selector.includes('[data-v-')) oaScore += 10;

            // 避免过长选择器扣分
            if (selector.length > 100) oaScore -= 20;
            if (selector.split(' ').length > 5) oaScore -= 10;

            return { selector, oaScore };
        });

        // 选择得分最高的选择器
        scoredSelectors.sort((a, b) => b.oaScore - a.oaScore);
        return scoredSelectors[0]?.selector;
    }

    // 生成基于属性的选择器 - 针对OA系统优化
    function generateAttributeBasedSelector(el) {
        const selectors = [];

        // OA系统常见的有意义属性
        const meaningfulAttrs = [
            'data-key', 'data-row-key', 'data-node-key',
            'fiber-id', 'data-v-*', 'title', 'role',
            'aria-label', 'data-testid', 'name'
        ];

        for (const attr of meaningfulAttrs) {
            if (attr.includes('*')) {
                // 处理通配符属性
                const prefix = attr.replace('*', '');
                for (const actualAttr of el.getAttributeNames()) {
                    if (actualAttr.startsWith(prefix)) {
                        const value = el.getAttribute(actualAttr);
                        if (value && value.length < 50 && !value.includes('toolbar')) {
                            selectors.push(`[${actualAttr}="${CSS.escape(value)}"]`);
                        }
                    }
                }
            } else if (el.hasAttribute(attr)) {
                const value = el.getAttribute(attr);
                if (value && value.length < 50 && !value.includes('toolbar')) {
                    selectors.push(`[${attr}="${CSS.escape(value)}"]`);
                }
            }
        }

        // 组合选择器：类名 + 属性
        if (el.className) {
            const classes = Array.from(el.classList).filter(cls =>
                cls.includes('table') ||
                cls.includes('list') ||
                cls.includes('pending') ||
                cls.startsWith('ant-table') ||
                cls.startsWith('ant-list')
            );

            for (const cls of classes) {
                for (const attr of meaningfulAttrs) {
                    if (!attr.includes('*') && el.hasAttribute(attr)) {
                        const value = el.getAttribute(attr);
                        if (value && value.length < 30) {
                            selectors.push(`.${CSS.escape(cls)}[${attr}="${CSS.escape(value)}"]`);
                        }
                    }
                }
            }
        }

        // 4. 类名选择器（过滤掉脚本添加的类）
        if (el.className && typeof el.className === 'string') {
            const classes = el.className.split(/\s+/).filter(cls =>
                cls &&
                /^[a-zA-Z_-][\w-]*$/.test(cls) &&
                !cls.startsWith('md-extractor') // 过滤掉脚本添加的类
            );

            if (classes.length > 0) {
                try {
                    // 尝试单个类
                    for (const cls of classes) {
                        selectors.push(`.${CSS.escape ? CSS.escape(cls) : cls}`);
                    }

                    // 尝试组合类（限制数量避免过于复杂）
                    if (classes.length > 1) {
                        const combined = classes.slice(0, 3).map(cls =>
                            CSS.escape ? CSS.escape(cls) : cls
                        ).join('.');
                        selectors.push(`.${combined}`);
                    }
                } catch (e) {
                    console.warn('类选择器生成失败:', e);
                }
            }
        }

        return selectors;
    }

    // 生成简化的路径选择器
    function generateSimplePath(el) {
        const path = [];
        let current = el;
        let depth = 0;
        const maxDepth = 5; // 限制路径深度

        while (current && current !== document.body && depth < maxDepth) {
            let selector = current.tagName.toLowerCase();

            // 添加重要的属性信息
            if (current.id) {
                try {
                    const escapedId = CSS.escape ? CSS.escape(current.id) : current.id;
                    selector = `${selector}#${escapedId}`;
                } catch (e) {
                    console.warn('路径中ID处理失败:', e);
                }
            } else if (current.className && typeof current.className === 'string') {
                const classes = current.className.split(/\s+/)
                    .filter(cls => cls &&
                        /^[a-zA-Z_-][\w-]*$/.test(cls) &&
                        !cls.startsWith('md-extractor') // 过滤掉脚本添加的类
                    )
                    .slice(0, 2); // 只取前两个类

                if (classes.length > 0) {
                    try {
                        const escapedClasses = classes.map(cls =>
                            CSS.escape ? CSS.escape(cls) : cls
                        ).join('.');
                        selector = `${selector}.${escapedClasses}`;
                    } catch (e) {
                        console.warn('路径中类处理失败:', e);
                    }
                }
            }

            path.unshift(selector);
            current = current.parentElement;
            depth++;
        }

        return path.length > 0 ? path.join(' > ') : '';
    }

    // 生成简单的位置选择器
    function generateSimplePositionSelector(el) {
        if (!el.parentElement) return '';

        const parent = el.parentElement;
        const siblings = Array.from(parent.children);
        const index = siblings.indexOf(el);

        if (index === -1) return '';

        const tagName = el.tagName.toLowerCase();

        // 如果父元素有ID，使用父ID + 子元素位置
        if (parent.id) {
            try {
                const parentId = CSS.escape ? CSS.escape(parent.id) : parent.id;
                return `#${parentId} > ${tagName}:nth-child(${index + 1})`;
            } catch (e) {
                console.warn('父元素ID选择器生成失败:', e);
            }
        }

        // 如果父元素有唯一类名
        if (parent.className && typeof parent.className === 'string') {
            const classes = parent.className.split(/\s+/).filter(cls =>
                cls &&
                /^[a-zA-Z_-][\w-]*$/.test(cls) &&
                !cls.startsWith('md-extractor') // 过滤掉脚本添加的类
            );

            if (classes.length > 0) {
                try {
                    const parentClass = CSS.escape ? CSS.escape(classes[0]) : classes[0];
                    const parentSelector = `.${parentClass}`;

                    // 测试父选择器是否唯一
                    const parentElements = document.querySelectorAll(parentSelector);
                    if (parentElements.length === 1) {
                        return `${parentSelector} > ${tagName}:nth-child(${index + 1})`;
                    }
                } catch (e) {
                    console.warn('父元素类选择器生成失败:', e);
                }
            }
        }

        // 使用父标签名
        return `${parent.tagName.toLowerCase()} > ${tagName}:nth-child(${index + 1})`;
    }

    // 清理旧的备用函数，替换为更可靠的实现
    function generateUniqueSelector(el) {
        if (!el || !el.tagName) return '';

        const selectors = generateAllSelectors(el);

        // 返回第一个有效的选择器
        for (const selector of selectors) {
            if (testSelector(selector, el)) {
                return selector;
            }
        }

        // 如果没有找到有效的选择器，尝试使用第一个能匹配到目标元素的选择器
        for (const selector of selectors) {
            try {
                const found = document.querySelector(selector);
                if (found === el) {
                    return selector;
                }
            } catch (e) {
                // 忽略无效选择器
            }
        }

        // 如果所有选择器都失败，返回标签名
        return el.tagName.toLowerCase();
    }

    function handleKeyDown(event) {
        if (isPickingMode && event.key === 'Escape') {
            event.preventDefault();
            exitPickingMode();
        }
    }

    // 测试选择器是否有效（简化版）
    function testSelector(selector, expectedElement) {
        if (!selector || !expectedElement) return false;

        try {
            // 临时移除脚本添加的类
            const tempRemovedClasses = [];
            [CONFIG.HIGHLIGHT_CLASS, CONFIG.HOVER_HIGHLIGHT_CLASS].forEach(cls => {
                if (expectedElement.classList.contains(cls)) {
                    expectedElement.classList.remove(cls);
                    tempRemovedClasses.push(cls);
                }
            });

            let isValid = false;
            let uniquenessScore = 0;
            try {
                const found = document.querySelector(selector);
                isValid = found === expectedElement;

                if (isValid) {
                    // 检查选择器的唯一性
                    const allMatches = document.querySelectorAll(selector);
                    uniquenessScore = allMatches.length === 1 ? 100 : Math.max(1, 100 - allMatches.length);

                    if (allMatches.length === 1) {
                        console.log(`✅选择器测试成功(唯一): "${selector}"`);
                    } else {
                        console.log(`⚠️选择器测试成功但不唯一: "${selector}" (匹配${allMatches.length}个元素, 分数:${uniquenessScore})`);
                    }
                } else {
                    console.log(`❌选择器测试失败: "${selector}"`, found);
                }
            } catch (queryError) {
                console.warn(`选择器 "${selector}" 语法错误:`, queryError);
            }

            // 为选择器添加质量分数
            if (isValid && selector.score === undefined) {
                selector.score = uniquenessScore;
            }

            // 恢复原来的类
            tempRemovedClasses.forEach(cls => expectedElement.classList.add(cls));

            return isValid;
        } catch (e) {
            return false;
        }
    }

    // 清理了复杂的选择器函数，保留简单有效的逻辑

    // 生成nth-child选择器
    function generateNthChildSelector(el) {
        const path = [];
        let current = el;
        let depth = 0;
        const maxDepth = 4; // 限制深度

        while (current && current.parentElement && depth < maxDepth) {
            const parent = current.parentElement;
            const siblings = Array.from(parent.children);
            const index = siblings.indexOf(current) + 1;

            let selector = current.tagName.toLowerCase();

            // 如果有兄弟元素，添加nth-child
            if (siblings.length > 1) {
                selector += `:nth-child(${index})`;
            }

            path.unshift(selector);
            current = parent;
            depth++;

            // 如果到达了有ID的元素，就停止
            if (current.id) {
                try {
                    const escapedId = CSS.escape ? CSS.escape(current.id) : current.id;
                    path.unshift(`#${escapedId}`);
                } catch (e) {
                    console.warn('nth-child路径中ID处理失败:', e);
                }
                break;
            }
        }

        return path.length > 0 ? path.join(' > ') : '';
    }

    // 生成基于文本内容的选择器（备选方案）
    function generateTextBasedSelector(el) {
        const text = (el.textContent || '').trim();
        if (!text || text.length > 50) return '';

        // 对于包含特定文本的元素，生成一个相对路径
        const tagName = el.tagName.toLowerCase();
        const parent = el.parentElement;

        if (parent) {
            const parentSelector = parent.id ?
                `#${CSS.escape ? CSS.escape(parent.id) : parent.id}` :
                parent.tagName.toLowerCase();

            // 查找同级中包含此文本的元素
            const siblings = Array.from(parent.children);
            const sameTextSiblings = siblings.filter(sibling =>
                sibling.textContent && sibling.textContent.trim() === text
            );

            if (sameTextSiblings.length === 1) {
                return `${parentSelector} > ${tagName}`;
            }
        }

        return '';
    }

    // =================================================================================
    // --- 核心提取逻辑 (Core Extraction Logic) ---
    // =================================================================================
    async function extractAndCopy() {
        if (selectionContext.source === 'iframe') {
            let iframeEl = document.getElementById(selectionContext.iframeId);

            // 如果通过ID找不到，尝试其他方法
            if (!iframeEl && selectionContext.iframeId) {
                console.warn('通过ID未找到iframe，尝试查找所有iframe');
                const iframes = document.querySelectorAll('iframe');
                for (let iframe of iframes) {
                    if (iframe.id === selectionContext.iframeId ||
                        iframe.id.includes('mde-iframe')) {
                        iframeEl = iframe;
                        console.log('找到备选iframe:', iframe.id);
                        break;
                    }
                }
            }

            if (iframeEl) {
                showStatus('正在从iframe提取...', 'info');
                console.log('Requesting extraction from iframe:', selectionContext.iframeId, 'with selector:', selectionContext.selector);
                const autoExpand = document.getElementById('auto-expand').checked;
                const structuredMode = document.getElementById('structured-mode').checked;
                iframeEl.contentWindow.postMessage({
                    type: 'doExtract',
                    selector: selectionContext.selector,
                    autoExpand,
                    structuredMode
                }, '*');
            } else {
                showStatus('错误: 找不到源iframe。尝试在当前页面提取...', 'warning');
                // 降级到当前页面提取
                selectionContext.source = 'top';
                const selectorInput = document.getElementById('selector-input');
                if (selectorInput && selectionContext.selector) {
                    selectorInput.value = selectionContext.selector;
                    // 递归调用，现在使用top模式
                    await extractAndCopy();
                    return;
                } else {
                    showStatus('无法提取：选择器丢失', 'error');
                }
            }
            return;
        }

        const selectorInput = document.getElementById('selector-input');
        if (!selectorInput) {
            showStatus('UI元素未找到', 'error');
            return;
        }

        const selector = selectorInput.value.trim();
        if (!selector) {
            showStatus('请先选择一个元素', 'error');
            return;
        }

        try {
            const element = document.querySelector(selector);
            if (!element) {
                showStatus('未找到元素，请重新选择', 'error');
                return;
            }

            showStatus('正在准备提取...', 'info');

            const autoExpandCheckbox = document.getElementById('auto-expand');
            if (autoExpandCheckbox && autoExpandCheckbox.checked) {
                await autoExpandContent(element);
            }

            const structuredModeCheckbox = document.getElementById('structured-mode');
            const structuredMode = structuredModeCheckbox ? structuredModeCheckbox.checked : true;

            showStatus('正在提取内容...', 'info');
            const content = processExtraction(element, structuredMode);

            if (content && content.trim()) {
                console.log('内容提取成功，长度:', content.length);
                // 先尝试自动复制
                const copySuccess = await copyToClipboard(content);

                // 如果自动复制失败，回退到手动复制
                if (!copySuccess) {
                    console.log('自动复制失败，显示手动复制对话框');
                    showManualCopyDialog(content);
                    showStatus('自动复制失败，请手动复制', 'info');
                }
            } else {
                showStatus('提取内容为空', 'error');
            }
        } catch (error) {
            showStatus(`提取失败: ${error.message}`, 'error');
            console.error("提取错误:", error);
        }
    }

    // 手动复制对话框
    function showManualCopyDialog(content) {
        // 删除可能存在的旧对话框
        const existingDialog = document.getElementById('manual-copy-dialog');
        if (existingDialog) {
            existingDialog.remove();
        }

        // 创建遮罩层
        const overlay = document.createElement('div');
        overlay.id = 'manual-copy-overlay';
        overlay.style.cssText = `
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important;
            background: rgba(0, 0, 0, 0.5) !important;
            z-index: 1000000 !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
        `;

        // 创建对话框
        const dialog = document.createElement('div');
        dialog.id = 'manual-copy-dialog';
        dialog.style.cssText = `
            width: 80% !important;
            max-width: 800px !important;
            max-height: 80% !important;
            background: white !important;
            border: 2px solid #007bff !important;
            border-radius: 8px !important;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3) !important;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif !important;
            overflow: hidden !important;
        `;

        dialog.innerHTML = `
            <div style="background: #007bff; color: white; padding: 15px; display: flex; justify-content: space-between; align-items: center;">
                <h3 style="margin: 0; font-size: 16px;">📋 手动复制内容</h3>
                <button id="close-dialog" style="background: none; border: none; color: white; font-size: 20px; cursor: pointer; padding: 0; width: 24px; height: 24px; line-height: 1;">×</button>
            </div>
            <div style="padding: 20px;">
                <p style="margin: 0 0 15px 0; color: #666; font-size: 14px;">
                    内容已提取完成，请选择以下文本并手动复制 (Ctrl+C 或 Cmd+C)：
                </p>
                <textarea id="manual-copy-textarea" readonly style="
                    width: 100%;
                    height: 400px;
                    border: 1px solid #ddd;
                    border-radius: 4px;
                    padding: 10px;
                    font-family: 'SF Mono', 'Courier New', monospace;
                    font-size: 13px;
                    line-height: 1.4;
                    resize: vertical;
                    box-sizing: border-box;
                ">${content.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</textarea>
                <div style="margin-top: 15px; text-align: center;">
                    <button id="select-all-btn" style="
                        background: #007bff;
                        color: white;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 4px;
                        cursor: pointer;
                        margin-right: 10px;
                        font-size: 14px;
                        transition: background 0.2s;
                    ">全选内容</button>
                    <button id="close-dialog-btn" style="
                        background: #6c757d;
                        color: white;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 4px;
                        cursor: pointer;
                        font-size: 14px;
                        transition: background 0.2s;
                    ">关闭</button>
                </div>
                <div style="margin-top: 10px; text-align: center; color: #666; font-size: 12px;">
                    提示：选中文本后使用 Ctrl+C (Windows) 或 Cmd+C (Mac) 复制
                </div>
            </div>
        `;

        overlay.appendChild(dialog);
        document.body.appendChild(overlay);

        // 自动选择所有文本
        const textarea = dialog.querySelector('#manual-copy-textarea');
        setTimeout(() => {
            textarea.focus();
            textarea.select();
        }, 100);

        // 绑定事件
        const closeBtn = dialog.querySelector('#close-dialog');
        const closeBtnBottom = dialog.querySelector('#close-dialog-btn');
        const selectAllBtn = dialog.querySelector('#select-all-btn');

        const closeDialog = () => {
            if (document.body.contains(overlay)) {
                document.body.removeChild(overlay);
            }
        };

        closeBtn.addEventListener('click', closeDialog);
        closeBtnBottom.addEventListener('click', closeDialog);

        selectAllBtn.addEventListener('click', () => {
            textarea.focus();
            textarea.select();
        });

        // 点击遮罩层关闭
        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) {
                closeDialog();
            }
        });

        // ESC键关闭
        const handleKeydown = (e) => {
            if (e.key === 'Escape') {
                closeDialog();
                document.removeEventListener('keydown', handleKeydown);
            }
        };
        document.addEventListener('keydown', handleKeydown);

        // 添加按钮悬停效果
        const buttons = dialog.querySelectorAll('button');
        buttons.forEach(button => {
            button.addEventListener('mouseenter', () => {
                if (button.style.background === 'rgb(0, 123, 255)') {
                    button.style.background = '#0056b3';
                } else if (button.style.background === 'rgb(108, 117, 125)') {
                    button.style.background = '#5a6268';
                }
            });
            button.addEventListener('mouseleave', () => {
                if (button.id === 'select-all-btn') {
                    button.style.background = '#007bff';
                } else if (button.id === 'close-dialog-btn') {
                    button.style.background = '#6c757d';
                }
            });
        });
    }

    // 智能查找最佳的表格容器元素
    function findOptimalTableContainer(element) {
        if (!element) return element;

        // 如果当前元素就包含表格，直接返回
        if (element.tagName === 'TABLE' || element.querySelector('table')) {
            console.log(`[MD Extractor] 当前元素 ${element.tagName} 包含表格，无需优化`);
            return element;
        }

        // 检查是否为OA系统的表格容器
        if (element.matches && (element.matches('[class*="multiRowVariableColumn"]') ||
                               element.matches('[class*="h-editgird"]') ||
                               element.matches('[style*="overflow"]'))) {
            console.log(`[MD Extractor] 当前元素是OA容器，无需优化`);
            return element;
        }

        // 向上查找包含表格的父元素
        let current = element.parentElement;
        while (current && current !== document.body) {
            // 检查是否包含表格
            if (current.querySelector('table')) {
                console.log(`[MD Extractor] 找到包含表格的父元素: ${current.tagName}.${current.className}`);
                return current;
            }

            // 检查是否为OA系统的表格容器
            if (current.matches && (current.matches('[class*="multiRowVariableColumn"]') ||
                                   current.matches('[class*="h-editgird"]') ||
                                   current.matches('[style*="overflow"]'))) {
                console.log(`[MD Extractor] 找到OA容器父元素: ${current.tagName}.${current.className}`);
                return current;
            }

            current = current.parentElement;
        }

        // 如果没有找到更好的容器，返回原始元素
        console.log(`[MD Extractor] 未找到更好的容器，使用原始元素`);
        return element;
    }

    function processExtraction(element, structuredMode) {
        if (!element) return '';

        console.log(`[MD Extractor] 开始处理元素: ${element.tagName}.${element.className} (${element.id})`);
        console.log(`[MD Extractor] 结构化模式: ${structuredMode}`);

        // 智能元素检测：如果用户选择了不包含表格的嵌套元素，自动找到包含表格的父元素
        const optimizedElement = findOptimalTableContainer(element);
        if (optimizedElement !== element) {
            console.log(`[MD Extractor] 自动优化选择: 从 ${element.tagName}.${element.className} 调整为 ${optimizedElement.tagName}.${optimizedElement.className}`);
            element = optimizedElement;
        }

        const clone = element.cloneNode(true);

        // 清理垃圾元素，但保护表格内容
        CONFIG.JUNK_SELECTORS.forEach(selector => {
            try {
                clone.querySelectorAll(selector).forEach(junk => {
                    // 如果是表格内的内容，跳过清理
                    if (junk.closest('table, tbody, tr, td, th, .h-editgird, .h-editgird-wrapper')) {
                        return;
                    }
                    if (junk.parentNode) {
                        junk.parentNode.removeChild(junk);
                    }
                });
            } catch (e) {
                console.warn(`[MD Extractor] Invalid selector: ${selector}`, e);
            }
        });

        // 智能清理onclick元素
        const onClickElements = clone.querySelectorAll('[onclick]');
        console.log(`[MD Extractor] 找到 ${onClickElements.length} 个onclick元素`);
        onClickElements.forEach(element => {
            const shouldRemove = shouldRemoveOnClickElement(element);
            console.log(`[MD Extractor] onclick元素决策: "${element.textContent}" -> ${shouldRemove ? '删除' : '保留'}`);
            if (shouldRemove) {
                if (element.parentNode) {
                    element.parentNode.removeChild(element);
                }
            }
        });

        if (structuredMode) {
            return extractStructuredData(clone);
        } else {
            return nodeToMarkdown(clone);
        }
    }

    function extractStructuredData(element) {
        // 不自动添加页面title作为一级标题，让选定区域内的h1-h6自然转换
        let markdown = '';
        console.log(`[MD Extractor] extractStructuredData开始处理: ${element.tagName}.${element.className}`);

        // 直接处理用户选择的元素，确保与HTML结构保持一致
        // 使用共享的processedElements来避免重复处理
        const processedElements = new Set();
        const contentMarkdown = nodeToMarkdown(element, processedElements);
        console.log(`[MD Extractor] nodeToMarkdown返回长度: ${contentMarkdown ? contentMarkdown.length : 0}`);

        if (contentMarkdown && contentMarkdown.trim()) {
            // 如果当前markdown不为空且新内容是代码块，确保前面有换行
            if (markdown.trim() && contentMarkdown.includes('```')) {
                if (!markdown.endsWith('\n')) {
                    markdown += '\n';
                }
            }
            markdown += contentMarkdown;
        }

        // 优化最终格式，只在代码块前添加换行
        return markdown
            .replace(/([^\n])```/g, '$1\n```')              // 只在代码块前添加一个换行
            .replace(/\n +/g, '\n')                         // 移除行首多余空格
            .replace(/^ +/g, '')                            // 移除开头的空格
            .replace(/^\s+|\s+$/g, '')                      // 去除首尾空白
            .trim();
    }

    // 检查table元素是否为HUI表格的一部分
    function checkIfPartOfHUITable(tableElement) {
        // 检查table是否在.h-table-header或.h-table-body容器中
        let parent = tableElement.parentElement;
        while (parent) {
            const classList = parent.classList;
            if (classList && (classList.contains('h-table-header') || classList.contains('h-table-body'))) {
                console.log(`[MD Extractor] 发现HUI表格容器: ${parent.className}`);
                return true;
            }
            parent = parent.parentElement;
        }
        return false;
    }

    // 检查并处理完整的HUI表格结构 - 只在容器选择时合并
    function processHUITableIfPresent(node, processedElements) {
        const classList = node.classList;
        if (!classList) return null;

        // 只在遇到完整的h-table容器时才进行合并处理
        // 如果是单独的h-table-header或h-table-body，让它们正常处理
        if (classList.contains('h-table')) {
            console.log(`[MD Extractor] 发现完整HUI表格容器: ${node.className}`);

            // 查找header和body
            const headerContainer = node.querySelector('.h-table-header');
            const bodyContainer = node.querySelector('.h-table-body');

            if (headerContainer && bodyContainer) {
                console.log('[MD Extractor] 找到完整的HUI表格结构，开始合并处理');

                // 标记这些容器为已处理
                processedElements.add(headerContainer);
                processedElements.add(bodyContainer);

                // 提取header和body中的table
                const headerTable = headerContainer.querySelector('table');
                const bodyTable = bodyContainer.querySelector('table');

                if (headerTable && bodyTable) {
                    processedElements.add(headerTable);
                    processedElements.add(bodyTable);

                    // 合并提取表格数据
                    const headerData = extractTableData(headerTable);
                    const bodyData = extractTableData(bodyTable);

                    if (headerData && bodyData) {
                        // 合并header和body的数据
                        const combinedTable = mergeHUITableData(headerData, bodyData);
                        console.log(`[MD Extractor] HUI表格合并完成，总长度: ${combinedTable.length}`);
                        return combinedTable;
                    }
                }
            }
        }


        return null;
    }

    // 尝试合并完整的HUI表格 - 用于通用提取智能合并
    function tryMergeCompleteHUITable(currentNode, processedElements) {
        console.log(`[MD Extractor] 尝试智能合并HUI表格: ${currentNode.className}`);

        // 查找父级的h-table容器
        let hTableContainer = null;
        let parent = currentNode.parentElement;

        while (parent) {
            if (parent.classList && parent.classList.contains('h-table')) {
                hTableContainer = parent;
                break;
            }
            parent = parent.parentElement;
        }

        if (!hTableContainer) {
            console.log('[MD Extractor] 未找到h-table容器，无法智能合并');
            return null;
        }

        console.log(`[MD Extractor] 找到h-table容器: ${hTableContainer.className}`);

        // 查找header和body
        const headerContainer = hTableContainer.querySelector('.h-table-header');
        const bodyContainer = hTableContainer.querySelector('.h-table-body');

        if (!headerContainer || !bodyContainer) {
            console.log('[MD Extractor] HUI表格结构不完整，无法合并');
            return null;
        }

        // 检查是否已经被处理过
        if (processedElements.has(headerContainer) || processedElements.has(bodyContainer) || processedElements.has(hTableContainer)) {
            console.log('[MD Extractor] HUI表格已被处理，避免重复');
            return null;
        }

        console.log('[MD Extractor] 开始智能合并完整HUI表格');

        // 标记相关元素为已处理
        processedElements.add(hTableContainer);
        processedElements.add(headerContainer);
        processedElements.add(bodyContainer);

        // 提取header和body中的table
        const headerTable = headerContainer.querySelector('table');
        const bodyTable = bodyContainer.querySelector('table');

        if (headerTable && bodyTable) {
            processedElements.add(headerTable);
            processedElements.add(bodyTable);

            // 合并提取表格数据
            const headerData = extractTableData(headerTable);
            const bodyData = extractTableData(bodyTable);

            if (headerData && bodyData) {
                const combinedTable = mergeHUITableData(headerData, bodyData);
                console.log(`[MD Extractor] 智能合并HUI表格完成，总长度: ${combinedTable.length}`);
                return combinedTable;
            }
        }

        return null;
    }

    // 合并HUI表格的header和body数据
    function mergeHUITableData(headerData, bodyData) {
        console.log(`[MD Extractor] 合并HUI表格数据 - Header长度: ${headerData.length}, Body长度: ${bodyData.length}`);

        // 分析header和body的结构
        const headerLines = headerData.trim().split('\n');
        const bodyLines = bodyData.trim().split('\n');

        // 找到header中的表格数据
        let headerTableLines = [];
        let bodyTableLines = [];

        for (const line of headerLines) {
            if (line.startsWith('|') && line.endsWith('|')) {
                headerTableLines.push(line);
            }
        }

        for (const line of bodyLines) {
            if (line.startsWith('|') && line.endsWith('|') && !line.includes('---')) {
                bodyTableLines.push(line);
            }
        }

        if (headerTableLines.length > 0 && bodyTableLines.length > 0) {
            // 构建完整表格：header + 分隔符 + body
            let combined = headerTableLines[0] + '\n'; // 表头

            // 添加分隔符行
            const headerCells = headerTableLines[0].split('|').filter(cell => cell.trim());
            const separator = '| ' + headerCells.map(() => '---').join(' | ') + ' |';
            combined += separator + '\n';

            // 添加body数据
            combined += bodyTableLines.join('\n');

            console.log(`[MD Extractor] 合并完成，最终长度: ${combined.length}`);
            return combined;
        }

        // 如果无法识别表格结构，简单合并
        return headerData.trim() + '\n' + bodyData.trim();
    }

    function nodeToMarkdown(node, processedElements = new Set()) {
        console.log(`[MD Extractor] nodeToMarkdown被调用: 节点类型=${node ? node.nodeType : 'null'}, 标签=${node && node.nodeType === 1 ? node.tagName : 'N/A'}`);
        if (!node || processedElements.has(node)) {
            console.log(`[MD Extractor] nodeToMarkdown早期返回: 节点为空=${!node}, 已处理=${processedElements.has(node)}`);
            return '';
        }

        // 移除了复杂的标记清理逻辑，回归v6.3.1的简单方式

        // 直接添加到处理集合，像6.3.1版本一样简单
        processedElements.add(node);

        const nodeType = node.nodeType;

        if (nodeType === (Node.TEXT_NODE || 3)) {
            const text = node.textContent || '';
            // 恢复v6.3.1的文本处理方式，保留必要的空格和换行
            if (text.trim()) {
                // 处理空白字符，保留可见字符之间的单个空格
                const cleanedText = text
                    .replace(/\r\n/g, ' ')        // 换行转空格
                    .replace(/\n/g, ' ')          // 换行转空格
                    .replace(/\t/g, ' ')          // Tab转空格
                    .replace(/\s+/g, ' ')         // 多个空格合并
                    .trim();
                return cleanedText ? cleanText(cleanedText) : '';
            }
            return '';
        }

        console.log(`[MD Extractor] 检查元素类型: nodeType=${nodeType}, ELEMENT_NODE=${Node.ELEMENT_NODE || 1}`);
        if (nodeType !== (Node.ELEMENT_NODE || 1)) {
            console.log(`[MD Extractor] 跳过非元素节点`);
            return '';
        }

        // 检查是否为被忽略的标签类型
        const tagName = node.tagName.toLowerCase();
        console.log(`[MD Extractor] 检查标签: ${tagName}, 忽略列表:`, CONFIG.IGNORE_TAGS);
        if (CONFIG.IGNORE_TAGS.includes(tagName)) {
            console.log(`[MD Extractor] 跳过忽略的标签: ${tagName}`);
            return '';
        }

        // 跳过隐藏元素 (补充v5.9的内联样式检查)
        console.log(`[MD Extractor] 检查元素样式: display=${node.style?.display}, visibility=${node.style?.visibility}`);
        if (node.style && (node.style.display === 'none' || node.style.visibility === 'hidden')) {
            console.log(`[MD Extractor] 跳过隐藏元素`);
            return '';
        }

        // 跳过明显的UI控件元素
        console.log(`[MD Extractor] 检查类名: ${node.className}`);
        if (node.className && typeof node.className === 'string') {
            const className = node.className.toLowerCase();
            if (className.includes('icon') ||
                className.includes('arrow') ||
                className.includes('dropdown') ||
                className.includes('placeholder') ||
                className.includes('helper')) {
                console.log(`[MD Extractor] 跳过UI控件元素: ${className}`);
                return '';
            }
        }

        // 检查是否为完整的HUI表格结构
        if (node.classList && node.classList.contains('h-table')) {
            const huiTableResult = processHUITableIfPresent(node, processedElements);
            if (huiTableResult) {
                console.log('[MD Extractor] 返回完整HUI表格结果');
                return huiTableResult;
            }
        }

        // 检查是否为包含HUI表格的容器（如用户选择的div容器）
        const hTableInside = node.querySelector && node.querySelector('.h-table');
        if (hTableInside && !processedElements.has(hTableInside)) {
            console.log(`[MD Extractor] 在容器中发现HUI表格: ${node.className || node.tagName}`);
            const containerResult = processHUITableIfPresent(hTableInside, processedElements);
            if (containerResult) {
                console.log('[MD Extractor] 容器内HUI表格处理完成');
                return containerResult;
            }
        }

        // 注意：节点已在开头添加到processedElements中，这里不需要重复添加

        let markdown = '';
        const isBlock = ['p', 'div', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'table', 'blockquote'].includes(tagName);
        console.log(`[MD Extractor] 处理元素: ${tagName}, 类名: ${node.className || 'none'}, 是否块级: ${isBlock}`);

        switch (tagName) {
            case 'h1':
            case 'h2':
            case 'h3':
            case 'h4':
            case 'h5':
            case 'h6':
                const level = parseInt(tagName[1]);
                const headerText = getChildMarkdown(node, processedElements);
                if (headerText.trim()) {
                    markdown = `${'#'.repeat(level)} ${headerText.trim()}`;
                }
                break;

            case 'p':
                markdown = getChildMarkdown(node, processedElements);
                break;

            case 'table':
                console.log('[MD Extractor] 检测到标准 table 元素');

                // 检查是否为HUI表格的一部分，如果是则跳过单独处理
                const isPartOfHUITable = checkIfPartOfHUITable(node);
                console.log(`[MD Extractor] 是否为HUI表格部分: ${isPartOfHUITable}`);

                if (!isPartOfHUITable) {
                    const tableData = extractTableData(node);
                    console.log(`[MD Extractor] 表格提取结果长度: ${tableData ? tableData.length : 0}`);
                    if (tableData) {
                        markdown = tableData;
                    }
                } else {
                    console.log('[MD Extractor] 跳过HUI表格部分，等待完整处理');
                }
                break;

            case 'ul':
            case 'ol':
                const listItems = Array.from(node.children).filter(child =>
                    child.tagName && child.tagName.toLowerCase() === 'li'
                );
                listItems.forEach((li, index) => {
                    const itemText = getChildMarkdown(li, processedElements);
                    if (itemText.trim()) {
                        const prefix = tagName === 'ul' ? '* ' : `${index + 1}. `;
                        markdown += `${prefix}${itemText.trim()}\n`;
                    }
                });
                break;

            case 'br':
                return '  \n'; // 改进：使用双空格+换行符实现Markdown换行

            case 'strong':
            case 'b':
                const strongText = getChildMarkdown(node, processedElements);
                if (strongText.trim()) {
                    markdown = `**${strongText.trim()}**`;
                }
                break;

            case 'em':
            case 'i':
                const emText = getChildMarkdown(node, processedElements);
                if (emText.trim()) {
                    markdown = `*${emText.trim()}*`;
                }
                break;

            case 'a':
                const linkText = getChildMarkdown(node, processedElements);
                const href = node.getAttribute('href');
                if (linkText.trim()) {
                    markdown = href ? `[${linkText.trim()}](${href})` : linkText;
                }
                break;

            case 'input':
                // 处理输入框的值
                const inputValue = getInputValue(node);
                if (inputValue) {
                    markdown = inputValue;
                }
                break;

            case 'select':
                // 处理选择框的值
                const selectValue = getSelectValue(node);
                if (selectValue) {
                    markdown = selectValue;
                }
                break;

            case 'textarea':
                // 处理文本区域的值
                const textareaValue = node.value || node.textContent || '';
                if (textareaValue.trim()) {
                    markdown = cleanText(textareaValue);
                }
                break;

            case 'code':
                // 行内代码
                const codeText = getChildMarkdown(node, processedElements);
                if (codeText.trim()) {
                    markdown = `\`${codeText.trim()}\``;
                }
                break;

            case 'pre':
                // 代码块
                const preText = node.textContent || '';
                if (preText.trim()) {
                    markdown = `\`\`\`\n${preText.trim()}\n\`\`\``;
                }
                break;

            case 'blockquote':
                // 引用块
                const quoteText = getChildMarkdown(node, processedElements);
                if (quoteText.trim()) {
                    const quotedLines = quoteText.trim().split('\n').map(line => `> ${line}`).join('\n');
                    markdown = quotedLines;
                }
                break;

            case 'img':
                // 图片
                const src = node.getAttribute('src');
                const alt = node.getAttribute('alt') || '图片';
                if (src) {
                    markdown = `![${alt}](${src})`;
                }
                break;

            case 'hr':
                // 分隔线
                markdown = '---';
                break;

            case 'span':
            case 'article':
            case 'section':
            case 'aside':
            case 'main':
            case 'header':
            case 'footer':
            case 'nav':
                // 语义化标签，直接处理子内容
                markdown = getChildMarkdown(node, processedElements);
                break;

            case 'label':
                // 表单标签，通常是字段标签，处理后添加换行
                const labelContent = getChildMarkdown(node, processedElements);
                if (labelContent.trim()) {
                    markdown = labelContent.trim();
                }
                break;

            default:
                console.log(`[MD Extractor] 进入default分支处理: ${tagName}, 类名: ${node.className || 'none'}`);

                // 检查是否为HUI表格的header或body容器
                if (node.classList && (node.classList.contains('h-table-header') || node.classList.contains('h-table-body'))) {
                    console.log(`[MD Extractor] 检测到HUI表格组件: ${node.className}`);

                    // 检查是否已经被处理过（避免重复处理）
                    if (processedElements.has(node)) {
                        console.log(`[MD Extractor] HUI表格组件已被处理，跳过: ${node.className}`);
                        return '';
                    }

                    // 尝试找到完整的HUI表格并合并
                    const completeMergedTable = tryMergeCompleteHUITable(node, processedElements);
                    if (completeMergedTable) {
                        console.log(`[MD Extractor] 成功合并完整HUI表格，长度: ${completeMergedTable.length}`);
                        markdown = completeMergedTable;
                    } else {
                        // 如果无法合并，直接提取内部的table
                        const internalTable = node.querySelector('table');
                        if (internalTable) {
                            console.log(`[MD Extractor] 直接处理HUI组件内的table`);
                            processedElements.add(internalTable);
                            processedElements.add(node); // 标记当前节点为已处理
                            markdown = extractTableData(internalTable);
                            console.log(`[MD Extractor] HUI组件table提取结果长度: ${markdown ? markdown.length : 0}`);
                        } else {
                            // 如果没有table，正常处理子内容
                            processedElements.add(node); // 标记当前节点为已处理
                            markdown = getChildMarkdown(node, processedElements);
                        }
                    }
                } else {
                    // 完全按照6.3.1版本的简单逻辑：对于其他元素，直接处理子内容
                    markdown = getChildMarkdown(node, processedElements);
                    console.log(`[MD Extractor] getChildMarkdown返回长度: ${markdown ? markdown.length : 0}`);
                }
                break;
        }

        // 完全按照6.3.1版本的return逻辑
        if (isBlock && markdown && markdown.trim()) {
            // 确保块级元素之间有适当间距
            if (!markdown.endsWith('\n\n')) {
                return markdown.trim() + '\n\n';
            }
            return markdown;
        }
        return markdown || '';
    }

    // 新增：获取输入框值的函数
    function getInputValue(input) {
        if (!input) return '';

        const type = (input.type || '').toLowerCase();

        switch (type) {
            case 'checkbox':
                if (input.checked) {
                    // 尝试获取相关联的标签文本
                    let labelText = '';

                    // 方法1: 通过for属性关联的label
                    if (input.id) {
                        const label = document.querySelector(`label[for="${input.id}"]`);
                        if (label) {
                            labelText = label.textContent.trim();
                        }
                    }

                    // 方法2: 父级label元素
                    if (!labelText) {
                        const parentLabel = input.closest('label');
                        if (parentLabel) {
                            labelText = parentLabel.textContent.replace(input.outerHTML, '').trim();
                        }
                    }

                    // 方法3: 紧邻的文本节点或元素
                    if (!labelText) {
                        const nextSibling = input.nextSibling;
                        if (nextSibling) {
                            if (nextSibling.nodeType === 3) { // 文本节点
                                labelText = nextSibling.textContent.trim();
                            } else if (nextSibling.nodeType === 1) { // 元素节点
                                labelText = nextSibling.textContent.trim();
                            }
                        }
                    }

                    // 使用复选框标记 + 文本
                    const displayText = labelText || input.value || '已选中';
                    return `☑ ${displayText}`;
                }
                return '';

            case 'radio':
                // 尝试获取相关联的标签文本
                let labelText = '';

                // 方法1: 通过for属性关联的label
                if (input.id) {
                    const label = document.querySelector(`label[for="${input.id}"]`);
                    if (label) {
                        labelText = label.textContent.trim();
                    }
                }

                // 方法2: 父级label元素
                if (!labelText) {
                    const parentLabel = input.closest('label');
                    if (parentLabel) {
                        labelText = parentLabel.textContent.replace(input.outerHTML, '').trim();
                    }
                }

                // 方法3: 紧邻的文本节点或元素
                if (!labelText) {
                    const nextSibling = input.nextSibling;
                    if (nextSibling) {
                        if (nextSibling.nodeType === 3) { // 文本节点
                            labelText = nextSibling.textContent.trim();
                        } else if (nextSibling.nodeType === 1) { // 元素节点
                            labelText = nextSibling.textContent.trim();
                        }
                    }
                }

                // 方法4: 查找同级的cap4-radio__left元素中的标签文本
                if (!labelText) {
                    const parentElement = input.closest('div, span, li, td');
                    if (parentElement) {
                        const radioLeft = parentElement.querySelector('.cap4-radio__left .label-margin, .cap4-radio__left .cap4-ctrl__label');
                        if (radioLeft) {
                            labelText = radioLeft.textContent.trim();
                        }
                    }
                }

                const displayText = labelText || input.value || input.getAttribute('value') || '';
                if (displayText) {
                    // 选中的用 ⊙，未选中的用 ○
                    const symbol = input.checked ? '⊙' : '○';
                    return `${symbol} ${displayText}`;
                }
                return '';

            case 'hidden':
                return ''; // 通常不显示隐藏字段

            default:
                const value = input.value || input.getAttribute('value') || '';
                if (value && value !== input.placeholder) {
                    return cleanText(value);
                }
                return '';
        }
    }

    // 新增：获取选择框值的函数
    function getSelectValue(select) {
        if (!select) return '';

        const selectedOption = select.querySelector('option[selected]') ||
                              select.options[select.selectedIndex];

        if (selectedOption) {
            const text = selectedOption.textContent || selectedOption.value || '';
            if (text && text !== '请选择' && text !== 'Please select' && text !== '- 请选择 -') {
                // 对于下拉选择框，使用下拉箭头图标来表示
                return `▼ ${cleanText(text)}`;
            }
        }

        // 如果没有选中项或者是默认的"请选择"，显示为未选择状态
        return '▼ (未选择)';
    }

    function getChildMarkdown(parentNode, processedElements) {
        if (!parentNode || !parentNode.childNodes) return '';
        console.log(`[MD Extractor] getChildMarkdown处理父节点: ${parentNode.tagName}, 子节点数量: ${parentNode.childNodes.length}`);

        let content = '';
        Array.from(parentNode.childNodes).forEach((child, index) => {
            const childMarkdown = nodeToMarkdown(child, processedElements);
            console.log(`[MD Extractor] 子节点${index}: ${child.nodeType === 1 ? child.tagName : 'TEXT'}, 返回长度: ${childMarkdown ? childMarkdown.length : 0}`);
            if (childMarkdown) {
                // 确保子节点之间有适当的分隔
                if (content && !content.endsWith(' ') && !childMarkdown.startsWith(' ')) {
                    content += ' ';
                }
                content += childMarkdown;
            }
        });
        console.log(`[MD Extractor] getChildMarkdown最终结果长度: ${content.length}`);
        return content;
    }

    function extractFormItemData(item, processedElements) {
        if (!item) return '';

        const labelEl = item.querySelector('.h-form-item-label, [class*="label"], label, .tbase-form-item-label');
        const contentEl = item.querySelector('.h-form-item-content, [class*="content"], .form-content, .t-base-view-mode');

        if (!labelEl || !contentEl) return '';

        const labelText = cleanText((labelEl.textContent || '').trim().replace(/[:：\s]*$/, ''));
        if (!labelText) return '';

        processedElements.add(item);

        // 处理表格
        const tables = contentEl.querySelectorAll('table');
        if (tables.length > 0) {
            let tableMarkdown = '';
            tables.forEach(table => {
                // 检查表格是否已经被处理过
                if (!processedElements.has(table)) {
                    processedElements.add(table);
                    const tableData = extractTableData(table);
                    if (tableData) {
                        tableMarkdown += tableData + '\n';
                    }
                }
            });
            if (tableMarkdown) {
                return `**${labelText}**:\n\n${tableMarkdown}\n`;
            }
        }

        // 获取实际值的多种策略
        let valueText = extractActualValue(contentEl);

        if (!valueText || valueText.trim() === '') {
            valueText = '(待填写)';
        }

        // 如果 valueText 包含表格（以 | 开头），则直接返回表格
        if (valueText.includes('|')) {
            return `**${labelText}**:\n\n${valueText}\n\n`;
        } else {
            // 确保标签和值之间有空格
            const cleanedValue = valueText.replace(/\s+/g, ' ').trim();
            return `**${labelText}**: ${cleanedValue}\n\n`;
        }
    }

    // seeyon OA 第一列内容提取函数
    function extractFirstColumnContent(cell) {
        // 1. 优先从链接的title属性提取完整标题
        const linkWithTitle = cell.querySelector('a[title]');
        if (linkWithTitle && linkWithTitle.getAttribute('title')) {
            return linkWithTitle.getAttribute('title').trim();
        }

        // 2. 从标题文本元素提取
        const titleElements = [
            '.titleText', '.cellContentText', '.title',
            '[class*="title"]', '[class*="subject"]'
        ];

        for (const selector of titleElements) {
            const element = cell.querySelector(selector);
            console.log(`[MD Extractor] 尝试选择器 "${selector}":`, element ? element.textContent : 'null');
            if (element && element.textContent && element.textContent.trim()) {
                // 清理标题中的多余空白和特殊字符
                let title = element.textContent.trim();
                // 移除连续的空白字符
                title = title.replace(/\s+/g, ' ');
                console.log(`[MD Extractor] 找到标题文本: "${title}"`);
                return title;
            }
        }

        // 3. 从链接文本提取
        const linkElement = cell.querySelector('a');
        if (linkElement && linkElement.textContent && linkElement.textContent.trim()) {
            let title = linkElement.textContent.trim();
            // 移除连续的空白字符
            title = title.replace(/\s+/g, ' ');
            return title;
        }

        // 4. 从单元格title属性提取
        const cellTitle = cell.getAttribute('title');
        if (cellTitle && cellTitle.trim()) {
            return cellTitle.trim();
        }

        // 5. 最后从单元格文本提取
        const finalContent = (cell.textContent || '').trim();
        console.log(`[MD Extractor] extractFirstColumnContent 最终结果: "${finalContent}"`);
        return finalContent;
    }

    // seeyon OA 可变列内容提取函数
    function extractVariableColumnContent(cell) {
        // 1. 优先从title属性提取（seeyon系统的主要数据存储方式）
        const titleAttr = cell.getAttribute('title');
        if (titleAttr && titleAttr.trim()) {
            return titleAttr.trim();
        }

        // 2. 从span元素的title属性提取
        const spanWithTitle = cell.querySelector('span[title]');
        if (spanWithTitle && spanWithTitle.getAttribute('title')) {
            return spanWithTitle.getAttribute('title').trim();
        }

        // 3. 从链接元素提取
        const linkElement = cell.querySelector('a');
        if (linkElement) {
            const linkTitle = linkElement.getAttribute('title');
            if (linkTitle && linkTitle.trim()) {
                return linkTitle.trim();
            }
            if (linkElement.textContent && linkElement.textContent.trim()) {
                return linkElement.textContent.trim();
            }
        }

        // 4. 从span文本内容提取
        const spanElement = cell.querySelector('span');
        if (spanElement && spanElement.textContent && spanElement.textContent.trim()) {
            return spanElement.textContent.trim();
        }

        // 5. 从div内容提取
        const divElement = cell.querySelector('div');
        if (divElement && divElement.textContent && divElement.textContent.trim()) {
            return divElement.textContent.trim();
        }

        // 6. 最后从单元格文本提取
        const cellText = (cell.textContent || '').trim();
        return cellText;
    }

    // 通用单元格内容提取函数
    function extractGenericCellContent(cell) {
        // 1. 从title属性提取
        const titleAttr = cell.getAttribute('title');
        if (titleAttr && titleAttr.trim()) {
            return titleAttr.trim();
        }

        // 2. 从子元素的title属性提取
        const elementWithTitle = cell.querySelector('[title]');
        if (elementWithTitle && elementWithTitle.getAttribute('title')) {
            return elementWithTitle.getAttribute('title').trim();
        }

        // 3. 从链接提取
        const linkElement = cell.querySelector('a');
        if (linkElement && linkElement.textContent && linkElement.textContent.trim()) {
            return linkElement.textContent.trim();
        }

        // 4. 从表单元素提取
        const inputElement = cell.querySelector('input, select, textarea');
        if (inputElement) {
            return getInputValue(inputElement) || inputElement.value || '';
        }

        // 5. 从文本内容提取
        return (cell.textContent || '').trim();
    }

    // 改进的实际值提取函数
    function extractActualValue(contentEl) {
        if (!contentEl) return '';



        // 策略1: 查找输入框的实际值
        const inputs = contentEl.querySelectorAll('input, textarea');
        for (const input of inputs) {
            const value = getInputValue(input);
            if (value && value.trim()) {
                return value; // getInputValue已经包含了cleanText处理
            }
        }

        // 处理select元素
        const selects = contentEl.querySelectorAll('select');
        for (const select of selects) {
            const value = getSelectValue(select);
            if (value && value.trim() && !value.includes('(未选择)')) {
                return value; // getSelectValue已经包含了cleanText处理
            }
        }

        // 策略2: 查找显示值的元素（包括可能被折叠的内容）
        const valueSelectors = [
            '.form-value', '.field-value', '.input-value', '.display-value',
            '.h-input-inner', '.h-select-selection-selected-value',
            '.h-date-editor-input', '.h-input', '.value',
            '[class*="value"]', '[class*="text"]', '[class*="display"]',
            '.content', '.detail', '.description', '.summary',
            'span:not([class*="icon"]):not([class*="arrow"]):not([class*="placeholder"])',
            'div:not([class*="icon"]):not([class*="arrow"]):not([class*="placeholder"])'
        ];

        for (const selector of valueSelectors) {
            try {
                const elements = contentEl.querySelectorAll(selector);
                for (const element of elements) {
                    const text = (element.textContent || '').trim();

                    // 排除明显的UI元素和占位符
                    if (text &&
                        text.length > 0 &&
                        text !== '请选择' &&
                        text !== '请输入' &&
                        text !== '待填写' &&
                        text !== '...' &&
                        text !== '—' &&
                        text !== '展开' &&
                        text !== '收起' &&
                        text !== '更多' &&
                        !text.includes('icon') &&
                        !text.includes('arrow') &&
                        !text.includes('dropdown')) {

                        // 检查是否是实际的内容而不是控件文本
                        if (isActualContent(text, element)) {
                            return cleanText(text);
                        }
                    }
                }
            } catch (e) {
                console.warn('提取值时选择器失败:', selector);
            }
        }

        // 策略3: 强制展开并获取隐藏内容
        const hiddenContent = extractHiddenContent(contentEl);
        if (hiddenContent) {
            return hiddenContent;
        }

        // 策略4: 直接提取可见文本（过滤掉控件元素）
        const clone = contentEl.cloneNode(true);

        // 移除所有控件和装饰性元素
        const elementsToRemove = [
            'button', 'i[class*="icon"]', 'svg', '.h-icon',
            '[class*="icon"]', '[class*="arrow"]', '[class*="dropdown"]',
            '.h-select-arrow', '.h-form-item-extra', '.h-poptip',
            '.h-tooltip', '.t-tag-primary', 'script', 'style',
            '[class*="placeholder"]', '[class*="helper"]',
            '.t-base-view-common-title' // 移除展开按钮容器
        ];

        elementsToRemove.forEach(selector => {
            try {
                clone.querySelectorAll(selector).forEach(el => {
                    if (el.parentNode) {
                        el.parentNode.removeChild(el);
                    }
                });
            } catch (e) {
                console.warn('清理选择器失败:', selector);
            }
        });

        const textContent = getTextWithSeparators(clone);

        // 进一步清理文本
        const cleanedText = textContent
            .replace(/\s+/g, ' ')
            .replace(/请选择|请输入|待填写|\.{3,}|—{2,}|展开|收起|更多/g, '')
            .trim();

        return cleanedText;
    }

    // 新增：提取隐藏内容的函数
    function extractHiddenContent(contentEl) {
        try {
            // 查找可能包含隐藏内容的元素
            const hiddenContainers = contentEl.querySelectorAll(
                '[style*="display: none"], [style*="display:none"], .collapsed, .hidden, [data-collapsed="true"]'
            );

            for (const container of hiddenContainers) {
                // 临时显示元素以获取内容
                const originalStyle = container.style.display;
                const originalClass = container.className;

                container.style.display = 'block';
                container.classList.remove('collapsed', 'hidden');

                const text = (container.textContent || '').trim();

                // 恢复原样式
                container.style.display = originalStyle;
                container.className = originalClass;

                if (text && text.length > 10 && !text.includes('展开') && !text.includes('icon')) {
                    return cleanText(text);
                }
            }

            // 查找可能的折叠内容
            const collapsibleElements = contentEl.querySelectorAll(
                '[data-toggle], [onclick*="toggle"], [onclick*="expand"], .expandable'
            );

            for (const element of collapsibleElements) {
                const text = (element.textContent || '').trim();
                if (text && text.length > 10) {
                    return cleanText(text);
                }
            }

        } catch (e) {
            console.warn('提取隐藏内容失败:', e);
        }

        return '';
    }

    // 新增：判断是否为实际内容的函数
    function isActualContent(text, element) {
        // 长度检查
        if (text.length > 100) return true; // 长文本很可能是实际内容
        if (text.length < 2) return false;   // 太短的文本可能不是有效内容

        // 数字模式检查（财务数据）
        if (/^\d{1,3}(,\d{3})*(\.\d+)?$/.test(text)) return true; // 格式化的数字
        if (/^\d+(\.\d+)?%?$/.test(text)) return true; // 数字或百分比
        if (/^\d{4}-\d{2}-\d{2}$/.test(text)) return true; // 日期格式

        // 中文内容检查
        if (/[\u4e00-\u9fa5]{2,}/.test(text)) {
            // 排除常见的UI文本
            const uiTexts = ['请选择', '请输入', '待填写', '展开', '收起', '更多', '确定', '取消', '保存'];
            return !uiTexts.some(ui => text.includes(ui));
        }

        // 英文内容检查
        if (/^[a-zA-Z\s]{3,}$/.test(text)) {
            const uiTexts = ['select', 'input', 'choose', 'enter', 'more', 'expand', 'collapse'];
            return !uiTexts.some(ui => text.toLowerCase().includes(ui));
        }

        // 检查元素的样式和位置
        if (element) {
            const computed = window.getComputedStyle(element);

            // 如果元素被隐藏，可能不是实际内容
            if (computed.display === 'none' || computed.visibility === 'hidden') {
                return false;
            }

            // 如果元素很小，可能是装饰性的
            const rect = element.getBoundingClientRect();
            if (rect.width < 10 || rect.height < 10) {
                return false;
            }
        }

        return true;
    }

    function extractTableData(table) {
        if (!table) return '';


        const matrix = [];
        const rows = Array.from(table.querySelectorAll('tr'));

        if (rows.length === 0) {
            return '';
        }

        // 处理每一行
        rows.forEach((row, y) => {
            if (!matrix[y]) matrix[y] = [];
            let x = 0;

            const cells = Array.from(row.querySelectorAll('td, th'));

            cells.forEach((cell, cellIndex) => {
                // 找到下一个空的位置
                while (matrix[y][x] !== undefined) x++;

                const colspan = parseInt(cell.getAttribute('colspan')) || 1;
                const rowspan = parseInt(cell.getAttribute('rowspan')) || 1;

                // 克隆单元格以移除"噪音"元素，避免影响原始页面
                const cellClone = cell.cloneNode(true);
                // 移除所有已知的图标、按钮等非内容元素，但保护有title属性的链接
                cellClone.querySelectorAll('.vportal, .setTop, button').forEach(el => el.remove());
                // 不移除有title属性的<a>标签，因为它们可能包含重要内容

                // 综合提取单元格内容
                let cellContent = '';

                // 1. 优先从内部的 <a> 标签的 title 属性获取（文档标题）
                const link = cellClone.querySelector('a[title]');
                if (link) {
                    const linkTitle = link.getAttribute('title') || '';
                    if (linkTitle.trim()) {
                        cellContent = cleanText(linkTitle);
                    }
                }

                // 2. 如果没有链接title，从单元格的 title 属性获取（用户名、时间等）
                if (!cellContent) {
                    const titleText = (cell.getAttribute('title') || '').trim();
                    if (titleText) {
                        cellContent = cleanText(titleText);
                    }
                }

                // 3. 如果还是空，从文本内容提取
                if (!cellContent) {
                    const visibleText = (cellClone.textContent || cellClone.innerText || '').trim();
                    if (visibleText) {
                        cellContent = cleanText(visibleText);
                    }
                }

                // 4. 最后尝试从输入框获取
                if (!cellContent) {
                    const input = cellClone.querySelector('input, textarea, select');
                    if (input) {
                        cellContent = getInputValue(input) || '';
                    }
                }

                // 清理和格式化内容
                cellContent = cleanTableCellContent(cellContent);

                if (!cellContent) {
                    cellContent = '';  // 空单元格
                }

                // 填充合并的单元格
                for (let i = 0; i < rowspan; i++) {
                    for (let j = 0; j < colspan; j++) {
                        const currentY = y + i;
                        const currentX = x + j;
                        if (!matrix[currentY]) matrix[currentY] = [];
                        matrix[currentY][currentX] = (i === 0 && j === 0) ? cellContent : '';
                    }
                }
                x += colspan;
            });
        });

        if (matrix.length === 0) {
            return '';
        }

        // 过滤掉所有单元格都为空的行
        const filteredMatrix = matrix.filter(row => {
            if (!row) return false;
            return row.some(cell => cell && cell.trim());
        });

        if (filteredMatrix.length === 0) {
            return '';
        }

        // 计算最大列数
        const maxCols = Math.max(...filteredMatrix.map(row => row ? row.length : 0));

        if (maxCols === 0) {
            return '';
        }

        // 确保所有行都有相同的列数 - 使用过滤后的矩阵
        filteredMatrix.forEach((row, index) => {
            if (!row) filteredMatrix[index] = [];
            while (filteredMatrix[index].length < maxCols) {
                filteredMatrix[index].push('');
            }
        });

        // 生成Markdown表格
        let markdown = '\n'; // 添加前置换行

        // 检查是否存在表头行 (th) - 在原始表格中检查
        const hasHeader = rows[0] && rows[0].querySelector('th');

        // 如果只有一行数据且没有表头，可能是分离的表格行，不添加分隔符
        const shouldAddSeparator = filteredMatrix.length > 1 || hasHeader;

        filteredMatrix.forEach((row, i) => {
            // 确保每个单元格都不为空，至少是一个空格
            const formattedRow = row.map(cell => {
                // 直接使用已经通过 cleanTableCellContent 处理过的内容
                let content = (cell || '').toString();
                return content || ' '; // 空单元格用空格占位
            });

            const rowContent = formattedRow.join(' | ');
            markdown += `| ${rowContent} |\n`;

            // 在第一行后添加分隔符
            // 只有在多行表格或有表头的情况下才添加分隔符
            if (i === 0 && shouldAddSeparator) {
                const separator = Array(maxCols).fill('---').join(' | ');
                markdown += `| ${separator} |\n`;
            }
        });

        markdown += '\n'; // 添加后置换行

        return markdown;
    }

    // 处理CSS布局的表格（如multiRowVariableColumn）
    function extractCSSTableData(container, processedElements = new Set()) {
        if (!container) return '';

        // 查找表格行 (tr 或者具有行特征的元素)
        const rows = container.querySelectorAll('tr, .row, [class*="row"], .h-editgird-row');

        // 如果是editgird表格，同时包含表头
        if (container.matches('[class*="editgird"]')) {
            const headerRows = container.querySelectorAll('.h-editgird-header tr');
            const bodyRows = container.querySelectorAll('.h-editgird-body tr, .h-editgird-row');
            const allRows = [...headerRows, ...bodyRows];
            if (allRows.length > 0) {
                return extractEditgirdTable(container, allRows);
            } else {
                // 特殊处理：seeyon OA系统的多种表格类型
                if (container.matches('[class*="multiRowVariableColumn"]') ||
                    container.querySelector('.multiRowVariableColumn') ||
                    container.querySelector('td.col_first') ||
                    container.querySelector('td.variableColumn') ||
                    container.matches('[class*="section-body"]') && container.querySelector('table')) {
                    return extractOAMultiRowTable(container);
                }

                // 尝试直接查找 table 标签（非OA表格）
                const tables = container.querySelectorAll('table');
                if (tables.length > 0) {
                    const table = tables[0];
                    // 检查是否已在processedElements中
                    if (processedElements.has(table)) {
                        console.log('[MD Extractor] Table在CSS提取中已在processedElements，跳过');
                        return '';
                    }

                    // 将table加入processedElements
                    processedElements.add(table);

                    // 检查是否为OA表格，如果是则使用OA提取器
                    if (table.querySelector('td.col_first') && table.querySelector('td.variableColumn')) {
                        return extractOAMultiRowTable(container);
                    } else {
                        return extractTableData(table);
                    }
                }
            }
        }

        if (rows.length === 0) {
            return '';
        }

        const matrix = [];

        rows.forEach((row, y) => {
            if (!matrix[y]) matrix[y] = [];

            // 查找单元格 (td, th 或者具有列特征的元素)
            const cells = row.querySelectorAll('td, th, .col, [class*="col"], [class*="cell"], .h-editgird-cell');

            cells.forEach((cell, x) => {
                // 跳过空的或者只有样式的单元格
                if (cell.classList.contains('setTopRow') || cell.classList.contains('col_first')) {
                    const isEmpty = !cell.textContent.trim() && !cell.getAttribute('title');
                    if (isEmpty) {
                        matrix[y][x] = '';
                        return;
                    }
                }

                let cellContent = '';

                // 专门处理 span 元素的内容
                const span = cell.querySelector('span[title]');
                if (span) {
                    // 优先从 span 的 title 属性获取
                    const titleText = span.getAttribute('title') || '';
                    if (titleText.trim()) {
                        cellContent = cleanText(titleText);
                    } else {
                        // 从 span 的文本内容获取
                        const textContent = getTextWithSeparators(span);
                        if (textContent.trim()) {
                            cellContent = cleanText(textContent);
                        }
                    }
                } else {
                    // 如果没有 span，尝试从单元格本身获取
                    const titleText = (cell.getAttribute('title') || '').trim();
                    if (titleText) {
                        cellContent = cleanText(titleText);
                    } else {
                        // 从文本内容获取
                        const textContent = getTextWithSeparators(cell);
                        if (textContent) {
                            cellContent = cleanText(textContent);
                        }
                    }
                }

                // 清理格式
                cellContent = cleanTableCellContent(cellContent);

                matrix[y][x] = cellContent || '';
            });
        });

        if (matrix.length === 0) {
            return '';
        }

        // 计算最大列数
        const maxCols = Math.max(...matrix.map(row => row ? row.length : 0));

        if (maxCols === 0) {
            return '';
        }

        // 确保所有行都有相同的列数
        matrix.forEach((row, index) => {
            if (!row) matrix[index] = [];
            while (matrix[index].length < maxCols) {
                matrix[index].push('');
            }
        });

        // 过滤掉全空行
        const filteredMatrix = matrix.filter(row =>
            row.some(cell => cell && cell.trim())
        );

        if (filteredMatrix.length === 0) {
            return '';
        }

        // 生成Markdown表格
        let markdown = '\n';

        // 如果只有一行数据，可能是分离的表格行，不添加分隔符
        const shouldAddSeparator = filteredMatrix.length > 1;

        filteredMatrix.forEach((row, i) => {
            const formattedRow = row.map(cell => {
                // 直接使用已经通过 cleanTableCellContent 处理过的内容
                let content = (cell || '').toString();
                return content || ' ';
            });

            const rowContent = formattedRow.join(' | ');
            markdown += `| ${rowContent} |\n`;

            // 在第一行后添加分隔符
            // 只有在多行表格的情况下才添加分隔符
            if (i === 0 && shouldAddSeparator) {
                const separator = Array(maxCols).fill('---').join(' | ');
                markdown += `| ${separator} |\n`;
            }
        });

        markdown += '\n';

        return markdown;
    }

    // 专门处理 h-editgird 表格
    function extractEditgirdTable(container, rows) {
        const matrix = [];

        rows.forEach((row, y) => {
            if (!matrix[y]) matrix[y] = [];

            // 查找单元格
            const cells = row.querySelectorAll('td, th');

            cells.forEach((cell, x) => {
                let cellContent = '';

                // 对于 h-editgird，优先从 span[title] 获取内容
                const span = cell.querySelector('span[title]');
                if (span) {
                    const titleText = span.getAttribute('title') || '';
                    if (titleText.trim()) {
                        cellContent = cleanText(titleText);
                    } else {
                        // 如果 title 为空，获取 span 的文本
                        const spanText = span.textContent || '';
                        if (spanText.trim()) {
                            cellContent = cleanText(spanText);
                        }
                    }
                } else {
                    // 如果没有 span[title]，查找任何 span
                    const anySpan = cell.querySelector('span');
                    if (anySpan) {
                        const spanText = anySpan.textContent || '';
                        if (spanText.trim()) {
                            cellContent = cleanText(spanText);
                        }
                    } else {
                        // 如果没有 span，从单元格的文本内容获取
                        const textContent = getTextWithSeparators(cell);
                        if (textContent) {
                            cellContent = cleanText(textContent);
                        }
                    }
                }

                // 清理格式
                cellContent = cleanTableCellContent(cellContent);

                matrix[y][x] = cellContent || '';
            });
        });

        if (matrix.length === 0) {
            return '';
        }

        // 计算最大列数
        const maxCols = Math.max(...matrix.map(row => row ? row.length : 0));

        if (maxCols === 0) {
            return '';
        }

        // 确保所有行都有相同的列数
        matrix.forEach((row, index) => {
            if (!row) matrix[index] = [];
            while (matrix[index].length < maxCols) {
                matrix[index].push('');
            }
        });

        // 生成Markdown表格
        let markdown = '\n';

        // 如果只有一行数据，可能是分离的表格行，不添加分隔符
        const shouldAddSeparator = matrix.length > 1;

        matrix.forEach((row, i) => {
            const formattedRow = row.map(cell => {
                // 直接使用已经通过 cleanTableCellContent 处理过的内容
                let content = (cell || '').toString();
                return content || ' ';
            });

            const rowContent = formattedRow.join(' | ');
            markdown += `| ${rowContent} |\n`;

            // 在第一行后添加分隔符
            if (i === 0 && shouldAddSeparator) {
                const separator = Array(maxCols).fill('---').join(' | ');
                markdown += `| ${separator} |\n`;
            }
        });

        markdown += '\n';

        return markdown;
    }

    // 智能判断onclick元素是否应该删除
    function shouldRemoveOnClickElement(element) {
        // 如果是表格内的内容链接，更加保守地保留
        if (element.closest('table, tbody, tr, td, th, .h-editgird, .h-editgird-wrapper, .multiRowVariableColumn')) {
            const classList = element.className || '';
            const text = element.textContent || '';
            const title = element.title || '';

            // 明确的功能按钮，应该删除
            if (classList.includes('setTop') || classList.includes('setTopRow') ||
                element.closest('.setTopRow') || element.closest('.setTop')) {
                console.log(`[MD Extractor] 删除功能按钮: ${text}`);
                return true;
            }

            // 检查父元素是否是功能按钮容器
            const parentDiv = element.closest('div.setTop, div.setTopRow');
            if (parentDiv) {
                console.log(`[MD Extractor] 删除功能按钮容器内容: ${text}`);
                return true;
            }

            // 对于表格内的其他onclick元素，默认保留
            // 只删除明确匹配垃圾模式的内容
            for (const pattern of CONFIG.ONCLICK_JUNK_PATTERNS) {
                if (pattern.test(text) || pattern.test(title)) {
                    console.log(`[MD Extractor] 删除垃圾内容: ${text}`);
                    return true;
                }
            }

            // 表格内的其他onclick元素默认保留
            console.log(`[MD Extractor] 保留表格内容: ${text}`);
            return false;
        }

        // 非表格区域的onclick元素，检查是否是垃圾
        const text = element.textContent || '';
        const title = element.title || '';

        for (const pattern of CONFIG.ONCLICK_JUNK_PATTERNS) {
            if (pattern.test(text) || pattern.test(title)) {
                return true;
            }
        }

        // 默认保留
        return false;
    }

    // 专门处理OA系统的 multiRowVariableColumn 表格
    function extractOAMultiRowTable(container) {
        // 防重复处理标记
        if (container.dataset && container.dataset.mdExtractorProcessed) {
            console.log('[MD Extractor] OA表格已处理，跳过重复处理');
            return '';
        }

        // 标记为已处理
        if (container.dataset) {
            container.dataset.mdExtractorProcessed = 'true';
        }

        // 查找所有的表格行 - 改进容器查找逻辑
        let tableContainer = container.querySelector('.multiRowVariableColumn') || container;
        let rows = tableContainer.querySelectorAll('table tr');

        // 如果找不到行，尝试直接在容器中查找
        if (rows.length === 0) {
            rows = container.querySelectorAll('tr');
        }

        // 如果还是找不到，尝试查找table元素
        if (rows.length === 0) {
            const table = container.querySelector('table');
            if (table) {
                rows = table.querySelectorAll('tr');
            }
        }

        if (rows.length === 0) {
            console.log('OA表格提取：未找到表格行');
            return '';
        }

        console.log(`[MD Extractor] OA表格提取：找到 ${rows.length} 行，容器:`, container.tagName, container.className);
        console.log(`[MD Extractor] 第一行HTML:`, rows[0] ? rows[0].innerHTML : 'null');

        const matrix = [];

        // 分析第一行，确定列的结构
        const firstRow = rows[0];
        const firstRowCells = firstRow.querySelectorAll('td');
        const columnNames = [];

        // 智能推断列名：根据实际数据内容和位置
        firstRowCells.forEach((cell, index) => {
            if (cell.classList.contains('col_first')) {
                columnNames.push('标题');
            } else if (cell.classList.contains('setTopRow')) {
                // 跳过置顶按钮列，不添加到columnNames
                return;
            } else if (cell.classList.contains('variableColumn')) {
                // 根据内容推断列名
                const titleAttr = cell.getAttribute('title') || '';
                const textContent = getTextWithSeparators(cell);

                // 通过内容模式推断列类型
                if (/^\d{4}-\d{2}-\d{2}/.test(titleAttr) || /^\d{2}-\d{2}/.test(titleAttr) || /今日|昨日|\d{2}:\d{2}/.test(textContent)) {
                    columnNames.push('时间');
                } else if (/[\u4e00-\u9fa5]{2,4}/.test(titleAttr) && titleAttr.length <= 10 && !/(待办|已办|发文|合同|审批|部门|公司|组织)/.test(titleAttr)) {
                    // 中文姓名：2-4个中文字符且不是业务术语
                    columnNames.push('人员');
                } else if (/待办|已办|发文|合同|审批|通知|申请|报告/.test(titleAttr)) {
                    columnNames.push('类型');
                } else if (/部门|公司|组织|分公司|子公司|中心/.test(titleAttr)) {
                    columnNames.push('部门');
                } else if (/重要|紧急|一般|高|中|低/.test(titleAttr)) {
                    columnNames.push('优先级');
                } else if (/未读|已读|已处理|待处理/.test(titleAttr)) {
                    columnNames.push('状态');
                } else if (/^\d+$/.test(titleAttr)) {
                    columnNames.push('编号');
                } else {
                    // 默认列名：根据位置推断
                    const columnIndex = columnNames.length + 1;
                    if (columnIndex === 2) {
                        columnNames.push('发起人');
                    } else if (columnIndex === 3) {
                        columnNames.push('时间');
                    } else {
                        columnNames.push(`列${columnIndex}`);
                    }
                }
            } else {
                columnNames.push(`列${columnNames.length + 1}`);
            }
        });

        // 添加表头
        if (columnNames.length > 0) {
            matrix.push(columnNames);
        }

        rows.forEach((row, rowIndex) => {
            const cells = row.querySelectorAll('td');
            const rowData = [];

            cells.forEach((cell, cellIndex) => {
                // 跳过置顶按钮列
                if (cell.classList.contains('setTopRow')) {
                    return;
                }

                let cellContent = '';

                if (cell.classList.contains('col_first')) {
                    // 第一列：提取标题信息
                    cellContent = extractFirstColumnContent(cell);
                    console.log(`[MD Extractor] 第一列内容: "${cellContent}", HTML:`, cell.innerHTML);
                } else if (cell.classList.contains('variableColumn')) {
                    // 其他列：提取各种类型的内容
                    cellContent = extractVariableColumnContent(cell);
                    console.log(`[MD Extractor] 变量列内容: "${cellContent}", title: "${cell.getAttribute('title')}"`);
                } else {
                    // 普通单元格
                    cellContent = extractGenericCellContent(cell);
                    console.log(`[MD Extractor] 普通单元格内容: "${cellContent}"`);
                }

                if (cellContent && cellContent.trim()) {
                    rowData.push(cleanTableCellContent(cellContent));
                } else {
                    rowData.push(''); // 保持列对齐
                }
            });

            // 过滤掉空行
            if (rowData.length > 0 && rowData.some(cell => cell.trim())) {
                matrix.push(rowData);
            }
        });

        console.log(`[MD Extractor] 处理完所有行后，矩阵长度: ${matrix.length}`);
        console.log(`[MD Extractor] 矩阵内容:`, matrix);

        if (matrix.length === 0) {
            console.log('[MD Extractor] OA表格矩阵为空，返回空字符串');
            return '';
        }

        // 计算最大列数
        const maxCols = Math.max(...matrix.map(row => row.length));

        // 确保所有行都有相同的列数
        matrix.forEach((row, index) => {
            while (row.length < maxCols) {
                row.push('');
            }
        });

        // 生成Markdown表格
        let markdown = '\n';

        // 如果只有一行数据，可能是分离的表格行，不添加分隔符
        const shouldAddSeparator = matrix.length > 1;

        matrix.forEach((row, i) => {
            const formattedRow = row.map(cell => cell || ' ');
            const rowContent = formattedRow.join(' | ');
            markdown += `| ${rowContent} |\n`;

            // 在第一行后添加分隔符
            // 只有在多行表格的情况下才添加分隔符
            if (i === 0 && shouldAddSeparator) {
                const separator = Array(maxCols).fill('---').join(' | ');
                markdown += `| ${separator} |\n`;
            }
        });

        markdown += '\n';

        console.log(`[MD Extractor] 生成的markdown长度: ${markdown.length}`);
        console.log(`[MD Extractor] 生成的markdown内容:`, markdown);

        return markdown;
    }

    // =================================================================================
    // --- 辅助函数 (Helper Functions) ---
    // =================================================================================

    // 专门用于清理表格单元格内容的函数
    function cleanTableCellContent(content) {
        if (!content) return '';

        let cleaned = content.toString();

        // 1. 移除HTML标签和注释
        cleaned = cleaned
            .replace(/<[^>]*>/g, '')           // 移除HTML标签
            .replace(/<!--[\s\S]*?-->/g, '')  // 移除HTML注释
            .replace(/&nbsp;/g, ' ')          // 转换&nbsp;为空格
            .replace(/&[a-zA-Z0-9]+;/g, ' '); // 移除HTML实体

        // 2. 智能处理换行符 - 更保守的处理
        cleaned = cleaned
            .replace(/\r\n/g, '\n')           // 统一换行符
            .replace(/\n{3,}/g, '\n\n')       // 最多保留两个换行符
            .replace(/\n\s*\n/g, '\n')        // 合并连续的空行
            .replace(/\n\s*[-•*]\s*/g, '; ')  // 列表项转为分号分隔
            .replace(/\n\s*\d+\.\s*/g, '; ')  // 数字列表转为分号分隔
            .replace(/\n{2,}/g, ' ')          // 段落分隔转为单个空格
            .replace(/\n/g, ' ')              // 剩余换行符转空格
            .replace(/\s+/g, ' ')             // 多个空格合并
            .trim();

        // 3. 转义Markdown特殊字符（只转义会破坏表格的字符）
        cleaned = cleaned
            .replace(/\|/g, '\\|');           // 转义管道符

        // 4. 处理过长内容
        if (cleaned.length > 150) {
            cleaned = cleaned.substring(0, 147) + '...';
        }

        return cleaned || ' '; // 空单元格用空格占位
    }

    // 获取带结构分隔符的文本内容
    function getTextWithSeparators(element) {
        if (!element) return '';

        let result = '';

        function traverse(node) {
            if (node.nodeType === Node.TEXT_NODE) {
                const text = node.textContent.trim();
                if (text) {
                    // 如果前面有文本且当前不以空格结尾，添加空格
                    if (result && !result.endsWith(' ')) {
                        result += ' ';
                    }
                    result += text;
                }
            } else if (node.nodeType === Node.ELEMENT_NODE) {
                // 忽略不可见元素
                const style = window.getComputedStyle(node);
                if (style.display === 'none' || style.visibility === 'hidden') {
                    return;
                }

                const tagName = node.tagName;

                // 处理cap4-radio组件
                if (node.classList && (node.classList.contains('cap4-radio__left') || node.classList.contains('cap4-radio'))) {
                    const labelElement = node.querySelector('.label-margin, .cap4-ctrl__label, .cap4-radio__left .label-margin, .cap4-radio__left .cap4-ctrl__label');
                    if (labelElement) {
                        const labelText = labelElement.textContent.trim();
                        if (labelText) {
                            // 检查是否选中：查找是-checked或其他选中状态的类
                            let isChecked = false;
                            const radioContainer = node.closest('.cap4-radio') || node;
                            if (radioContainer && radioContainer.classList) {
                                isChecked = radioContainer.classList.contains('is-checked') ||
                                           radioContainer.classList.contains('checked') ||
                                           radioContainer.classList.contains('selected');
                            }

                            const symbol = isChecked ? '⊙' : '○';
                            if (result && !result.endsWith(' ')) {
                                result += ' ';
                            }
                            result += `${symbol} ${labelText}`;
                            if (!result.endsWith(' ')) {
                                result += ' ';
                            }
                            return; // 已处理，不需要继续递归
                        }
                    }
                }

                // 扩展需要分隔符的元素类型
                const isBlockElement = ['DIV', 'P', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'LI', 'TD', 'TH', 'SECTION', 'ARTICLE', 'HEADER', 'FOOTER', 'UL', 'OL', 'DL', 'FORM', 'FIELDSET'].includes(tagName);
                const isInlineElementNeedsSeparator = ['SPAN', 'LABEL', 'A', 'BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'EM', 'STRONG', 'B', 'I', 'CODE', 'KBD', 'SAMP', 'VAR'].includes(tagName);

                // 检查是否是相邻的兄弟元素，如果是则在前面添加分隔符
                const isAdjacentSibling = node.previousSibling &&
                    node.previousSibling.nodeType === Node.ELEMENT_NODE &&
                    result && !result.endsWith(' ');

                // 检查是否是段落开始（避免在段落开始添加空格）
                const isParagraphStart = result === '' || result.endsWith('\n') || result.endsWith('\n\n');

                // 在元素开始前添加分隔符（如果需要且不是段落开始）
                if ((isBlockElement || isInlineElementNeedsSeparator || isAdjacentSibling) &&
                    result && !result.endsWith(' ') && !isParagraphStart) {
                    result += ' ';
                }

                // 递归处理子节点
                for (let child of node.childNodes) {
                    traverse(child);
                }

                // 在元素结束后添加分隔符（如果需要）
                if ((isBlockElement || isInlineElementNeedsSeparator) && result && !result.endsWith(' ')) {
                    // 检查是否有下一个兄弟元素，如果有则添加分隔符
                    const hasNextSibling = node.nextSibling &&
                        (node.nextSibling.nodeType === Node.ELEMENT_NODE ||
                         (node.nextSibling.nodeType === Node.TEXT_NODE && node.nextSibling.textContent.trim()));

                    if (hasNextSibling) {
                        result += ' ';
                    }
                }
            }
        }

        traverse(element);

        // 清理多余的空白符
        return result.replace(/\s+/g, ' ').trim();
    }

    function cleanText(text) {
        if (typeof text !== 'string') return '';

        let cleanedText = text;

        // 应用清理规则，但保留有意义的内容
        CONFIG.CLEANUP_KEYWORDS.forEach(keyword => {
            if (keyword instanceof RegExp) {
                cleanedText = cleanedText.replace(keyword, '');
            }
        });

        // 清理多余的空白字符，但保留格式
        cleanedText = cleanedText
            .replace(/\r\n/g, '\n')          // 统一换行符
            .replace(/\t/g, ' ')             // Tab转空格
            .replace(/[ ]{2,}/g, ' ')        // 多个空格合并为一个（保留单个空格）
            .replace(/\n +/g, '\n')          // 行首空格
            .replace(/ +\n/g, '\n')          // 行尾空格
            .replace(/\n{3,}/g, '\n\n')      // 多个换行符合并为两个
            .trim();

        // 移除常见的无意义文本，但保留实际数据
        const meaninglessPatterns = [
            /^请选择$/,
            /^请输入$/,
            /^待填写$/,
            /^\.{3,}$/,
            /^—+$/,
            /^-+$/,
            /^\s*$/,
            /^undefined$/,
            /^null$/,
            /^NaN$/
        ];

        for (const pattern of meaninglessPatterns) {
            if (pattern.test(cleanedText)) {
                return '';
            }
        }

        // 如果文本很短且可能是UI元素文本，进行额外检查
        if (cleanedText.length < 10) {
            const uiTexts = [
                '展开', '收起', '更多', '确定', '取消', '保存', '编辑', '删除',
                '添加', '新增', '修改', '查看', '详情', '返回', '关闭', '提交',
                'icon', 'arrow', 'dropdown'
            ];

            if (uiTexts.some(ui => cleanedText.includes(ui))) {
                return '';
            }
        }

        return cleanedText;
    }

    // 增强的内容检查函数（来自v6.3.1的改进）
    function isActualContent(text, element) {
        // 长度检查
        if (text.length > 100) return true; // 长文本可能是实际内容
        if (text.length < 2) return false;   // 太短无法成为有效内容

        // 数字模式检查（财务数据）
        if (/^\d{1,3}(,\d{3})*(\.\d+)?$/.test(text)) return true; // 格式化数字
        if (/^\d+(\.\d+)?%?$/.test(text)) return true; // 数字或百分比
        if (/^\d{4}-\d{2}-\d{2}$/.test(text)) return true; // 日期格式

        // 中文内容检查
        if (/[\u4e00-\u9fa5]{2,}/.test(text)) {
            const uiTexts = ['请选择', '请输入', '待填写', '展开', '收起', '更多', '确定', '取消', '保存'];
            return !uiTexts.some(ui => text.includes(ui));
        }

        // 英文内容检查
        if (/^[a-zA-Z\s]{3,}$/.test(text)) {
            const uiTexts = ['select', 'input', 'choose', 'enter', 'more', 'expand', 'collapse'];
            return !uiTexts.some(ui => text.toLowerCase().includes(ui));
        }

        // 元素样式和位置检查
        if (element) {
            const computed = window.getComputedStyle(element);

            // 隐藏元素可能不是实际内容
            if (computed.display === 'none' || computed.visibility === 'hidden') {
                return false;
            }

            // 非常小的元素可能是装饰性的
            const rect = element.getBoundingClientRect();
            if (rect.width < 10 || rect.height < 10) {
                return false;
            }
        }

        return true;
    }


    function autoDetectContent() {
        console.log('🔍 开始智能检测...');

        const selectors = [
            // 常见的主内容区域选择器
            '[class*="tbase-factor-main"]',
            '#subapp-container',
            '#data_app_container',
            '.h-layout-main-container',
            '.h-layout-content',
            '[class*="tbase-page"]',
            '.bizframe',
            '[class*="main-content"]',
            'main',
            '[role="main"]',
            '.container',
            '.content',
            '#content',
            '.main-container',
            '.page-content'
        ];

        for (const selector of selectors) {
            try {
                const element = document.querySelector(selector);
                if (element && isValidContent(element)) {
                    const selectorInput = document.getElementById('selector-input');
                    if (selectorInput) {
                        selectorInput.value = selector;
                    }
                    highlightElement(selector);
                    showStatus(`✅ 智能检测成功: ${selector}`, 'success');
                    return;
                }
            } catch (e) {
                console.warn('智能检测选择器无效:', selector, e);
            }
        }

        showStatus('❌ 未检测到最佳内容区域，请手动选择', 'error');
    }

    function isValidContent(element) {
        if (!element || typeof element.getBoundingClientRect !== 'function') {
            return false;
        }

        try {
            const rect = element.getBoundingClientRect();
            if (rect.width < 200 || rect.height < 100) {
                return false;
            }

            const text = element.innerText || element.textContent || '';
            if (text.trim().length < 50) {
                return false;
            }

            // 检查是否包含有意义的内容
            const hasFormContent = element.querySelector('form, table, .h-form-item, input, textarea, select');
            const hasBusinessContent = /产品|信托|投资|审批|内容|信息|数据|表格/.test(text);

            return hasFormContent || hasBusinessContent || text.length > 500;
        } catch (e) {
            console.warn('验证内容时出错:', e);
            return false;
        }
    }

    async function autoExpandContent(element) {
        if (!element) return;

        try {
            showStatus('正在查找可展开内容...', 'info');

            // 分多轮进行展开，确保展开后新出现的内容也能被展开
            let totalExpanded = 0;
            const maxRounds = 3; // 最多3轮展开

            for (let round = 0; round < maxRounds; round++) {
                console.log(`开始第 ${round + 1} 轮展开...`);

                const expandedThisRound = await performExpandRound(element);
                totalExpanded += expandedThisRound;

                if (expandedThisRound === 0) {
                    console.log('本轮未找到新的展开内容，停止');
                    break;
                }

                // 等待页面更新
                await new Promise(resolve => setTimeout(resolve, 1000));
            }

            if (totalExpanded > 0) {
                showStatus(`总共成功展开 ${totalExpanded} 个内容区域`, 'success');
            } else {
                showStatus('未找到可展开内容', 'info');
            }

        } catch (e) {
            console.warn('自动展开内容时出错:', e);
            showStatus('自动展开时出现错误', 'error');
        }
    }

    async function performExpandRound(element) {
        const clickTargets = [];

        // 策略1: 查找包含"展开"文本的元素
        const textElements = element.querySelectorAll('*');
        for (const el of textElements) {
            const text = el.textContent || '';
            const hasExpandText = /展开|更多|查看更多|显示更多|show more|expand/i.test(text);

            if (hasExpandText && text.trim().length < 20) { // 避免选中包含大量文本的容器
                // 检查是否可能是点击目标
                const isClickTarget = el.onclick ||
                                    el.getAttribute('onclick') ||
                                    el.style.cursor === 'pointer' ||
                                    ['A', 'BUTTON'].includes(el.tagName) ||
                                    el.classList.contains('clickable') ||
                                    el.hasAttribute('data-click') ||
                                    el.closest('[onclick]') ||
                                    el.querySelector('[onclick]');

                if (isClickTarget || el.classList.contains('t-base-view-common-title')) {
                    clickTargets.push(el);
                    console.log('找到展开目标:', el, '文本:', text.trim());
                }
            }
        }

        // 策略2: 查找特定的展开结构
        const expandStructures = [
            '.t-base-view-common-title',
            '[class*="expand"]',
            '[class*="more"]',
            '[class*="toggle"]',
            '[class*="collapse"]',
            '[data-toggle]',
            '[data-expand]',
            '.expandable',
            '.collapsible'
        ];

        for (const selector of expandStructures) {
            try {
                const elements = element.querySelectorAll(selector);
                elements.forEach(el => {
                    const text = el.textContent || '';
                    if (/展开|更多|expand|more/i.test(text) && !clickTargets.includes(el)) {
                        clickTargets.push(el);
                        console.log('找到展开结构:', el, '选择器:', selector);
                    }
                });
            } catch (e) {
                console.warn('展开结构查找失败:', selector, e);
            }
        }

        // 策略3: 查找带有特定图标的可点击元素
        const iconElements = element.querySelectorAll('i[class*="arrow"], i[class*="down"], i[class*="expand"], .iconfont, [class*="icon-"]');
        iconElements.forEach(icon => {
            const clickableParent = icon.closest('[onclick], .clickable, button, a') || icon.parentElement;
            if (clickableParent) {
                const text = clickableParent.textContent || '';
                if (/展开|更多|expand|more/i.test(text) && !clickTargets.includes(clickableParent)) {
                    clickTargets.push(clickableParent);
                    console.log('找到图标展开按钮:', clickableParent);
                }
            }
        });

        // 去重并过滤已处理的元素
        const uniqueTargets = [...new Set(clickTargets)].filter(target => {
            // 避免重复点击已经展开的内容
            const text = target.textContent || '';
            return !text.includes('收起') && !target.dataset.expanded;
        });

        if (uniqueTargets.length === 0) {
            return 0;
        }

        console.log(`本轮找到 ${uniqueTargets.length} 个展开目标`);

        let successCount = 0;
        for (const btn of uniqueTargets) {
            try {
                console.log('尝试点击展开按钮:', btn);

                const success = await tryClickElement(btn);
                if (success) {
                    successCount++;
                    btn.dataset.expanded = 'true'; // 标记已处理

                    // 每次点击后等待一下
                    await new Promise(resolve => setTimeout(resolve, 300));
                }

            } catch (e) {
                console.warn('点击展开按钮失败:', btn, e);
            }
        }

        return successCount;
    }

    async function tryClickElement(element) {
        const clickMethods = [
            // 方法1: 标准点击
            () => {
                element.click();
                return true;
            },

            // 方法2: 事件分发
            () => {
                const event = new MouseEvent('click', {
                    bubbles: true,
                    cancelable: true,
                    view: window
                });
                return element.dispatchEvent(event);
            },

            // 方法3: 执行onclick属性
            () => {
                const onclick = element.getAttribute('onclick');
                if (onclick) {
                    try {
                        new Function(onclick).call(element);
                        return true;
                    } catch (e) {
                        console.warn('执行onclick失败:', e);
                        return false;
                    }
                }
                return false;
            },

            // 方法4: 调用onclick函数
            () => {
                if (typeof element.onclick === 'function') {
                    element.onclick();
                    return true;
                }
                return false;
            },

            // 方法5: 尝试点击子元素
            () => {
                const clickableChild = element.querySelector('span, div, i, a, button');
                if (clickableChild) {
                    clickableChild.click();
                    return true;
                }
                return false;
            },

            // 方法6: 模拟鼠标事件序列
            () => {
                ['mousedown', 'mouseup', 'click'].forEach(eventType => {
                    const event = new MouseEvent(eventType, {
                        bubbles: true,
                        cancelable: true,
                        view: window
                    });
                    element.dispatchEvent(event);
                });
                return true;
            }
        ];

        // 尝试每种点击方式
        for (let i = 0; i < clickMethods.length; i++) {
            try {
                const result = clickMethods[i]();
                if (result) {
                    console.log(`点击方法 ${i + 1} 成功`);
                    return true;
                }
            } catch (e) {
                console.warn(`点击方法 ${i + 1} 失败:`, e);
            }
        }

        console.warn('所有点击方法都失败了');
        return false;
    }

    async function copyToClipboard(text) {
        if (!text) {
            showStatus('没有内容可复制', 'error');
            return false;
        }

        try {
            // 优先使用现代 Clipboard API
            if (navigator.clipboard && window.isSecureContext) {
                await navigator.clipboard.writeText(text);
                showStatus(`✅ 已复制 ${text.length} 字符`, 'success');
                return true;
            }
        } catch (err) {
            console.warn('Clipboard API 失败，回退到传统方法:', err);
        }

        // 回退到传统方法
        return execCommandCopy(text);
    }

    function execCommandCopy(text) {
        try {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.cssText = `
                position: fixed !important;
                top: -9999px !important;
                left: -9999px !important;
                opacity: 0 !important;
                pointer-events: none !important;
            `;

            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();

            const successful = document.execCommand('copy');
            document.body.removeChild(textArea);

            if (successful) {
                showStatus(`✅ 已复制 ${text.length} 字符 (兼容模式)`, 'success');
                return true;
            } else {
                showStatus('自动复制失败，请使用手动复制', 'error');
                console.error('execCommand copy failed');
                return false;
            }
        } catch (err) {
            console.error('Fallback copy failed:', err);
            showStatus('自动复制失败，请使用手动复制', 'error');
            return false;
        }
    }

    async function previewContent() {
        showStatus('正在生成预览...', 'info');

        if (selectionContext.source === 'iframe') {
            let iframeEl = document.getElementById(selectionContext.iframeId);

            // 如果通过ID找不到，尝试其他方法
            if (!iframeEl && selectionContext.iframeId) {
                console.warn('预览: 通过ID未找到iframe，尝试查找所有iframe');
                const iframes = document.querySelectorAll('iframe');
                for (let iframe of iframes) {
                    if (iframe.id === selectionContext.iframeId ||
                        iframe.id.includes('mde-iframe')) {
                        iframeEl = iframe;
                        console.log('预览: 找到备选iframe:', iframe.id);
                        break;
                    }
                }
            }

            if (iframeEl) {
                console.log('Requesting preview from iframe:', selectionContext.iframeId, 'with selector:', selectionContext.selector);
                const autoExpand = document.getElementById('auto-expand').checked;
                const structuredMode = document.getElementById('structured-mode').checked;
                iframeEl.contentWindow.postMessage({
                    type: 'doPreview',
                    selector: selectionContext.selector,
                    autoExpand,
                    structuredMode
                }, '*');
            } else {
                showStatus('错误: 找不到源iframe。尝试在当前页面预览...', 'warning');
                // 降级到当前页面预览
                selectionContext.source = 'top';
                const selectorInput = document.getElementById('selector-input');
                if (selectorInput && selectionContext.selector) {
                    selectorInput.value = selectionContext.selector;
                    // 递归调用，现在使用top模式
                    await previewContent();
                    return;
                } else {
                    showStatus('无法预览：选择器丢失', 'error');
                }
            }
            return;
        }

        const selector = document.getElementById('selector-input').value.trim();
        if (!selector) {
            showStatus('请先选择一个元素', 'error');
            return;
        }

        try {
            const element = document.querySelector(selector);
            if (!element) {
                showStatus('未找到元素', 'error');
                return;
            }

            const autoExpandCheckbox = document.getElementById('auto-expand');
            if (autoExpandCheckbox && autoExpandCheckbox.checked) {
                await autoExpandContent(element);
            }

            const structuredModeCheckbox = document.getElementById('structured-mode');
            const structuredMode = structuredModeCheckbox ? structuredModeCheckbox.checked : true;

            const content = processExtraction(element, structuredMode);

            if (!content || !content.trim()) {
                showStatus('预览内容为空', 'error');
                openPreviewWindow('<!-- 预览内容为空 -->', 'Markdown 预览 (空)');
                return;
            }

            openPreviewWindow(content);
            showStatus('预览已生成', 'success');

        } catch (error) {
            showStatus(`预览失败: ${error.message}`, 'error');
            console.error('预览错误:', error);
        }
    }

    async function handleExportHtml() {
        showStatus('正在导出HTML...', 'info');

        if (selectionContext.source === 'iframe') {
            const iframeEl = document.getElementById(selectionContext.iframeId);
            if (iframeEl) {
                console.log('Requesting HTML export from iframe:', selectionContext.iframeId, 'with selector:', selectionContext.selector);
                iframeEl.contentWindow.postMessage({
                    type: 'doExportHtml',
                    selector: selectionContext.selector,
                }, '*');
            } else {
                showStatus('错误: 找不到源iframe。', 'error');
            }
            return;
        }

        const selector = document.getElementById('selector-input').value.trim();
        if (!selector) {
            showStatus('请先选择一个元素', 'error');
            return;
        }

        console.log('[HTML Export] 当前选择器:', selector);
        showStatus(`正在导出HTML... 选择器: ${selector}`, 'info');

        try {
            const element = document.querySelector(selector);
            if (!element) {
                showStatus('未找到元素', 'error');
                return;
            }

            // 检查选择的元素是否包含工具界面
            if (element.closest('#md-extractor-toolbar') ||
                element.closest('#md-extractor-preview-window') ||
                element.closest('#md-extractor-modal') ||
                element.closest('[id*="md-extractor"]') ||
                element.querySelector('#md-extractor-toolbar') ||
                element.querySelector('#md-extractor-preview-window') ||
                element.querySelector('#md-extractor-modal') ||
                element.querySelector('[id*="md-extractor"]')) {
                showStatus('选择范围包含工具界面，请重新选择更精确的元素', 'error');
                return;
            }

            // 使用与Markdown提取相同的逻辑，先清理不可见元素
            const clonedElement = element.cloneNode(true);

            // 移除不可见和垃圾元素，确保与Markdown提取一致，但保护表格内容
            CONFIG.JUNK_SELECTORS.forEach(selector => {
                try {
                    clonedElement.querySelectorAll(selector).forEach(junk => {
                        // 如果是表格内的内容，跳过清理
                        if (junk.closest('table, tbody, tr, td, th, .h-editgird, .h-editgird-wrapper, .multiRowVariableColumn')) {
                            return;
                        }
                        if (junk.parentNode) {
                            junk.parentNode.removeChild(junk);
                        }
                    });
                } catch (e) {
                    console.warn(`[MD Extractor] Invalid selector: ${selector}`, e);
                }
            });

            // 智能清理onclick元素
            const onClickElements = clonedElement.querySelectorAll('[onclick]');
            onClickElements.forEach(element => {
                if (shouldRemoveOnClickElement(element)) {
                    if (element.parentNode) {
                        element.parentNode.removeChild(element);
                    }
                }
            });

            // 移除工具自身的UI元素，避免导出HTML中包含工具界面
            console.log('[HTML Export] 开始清理工具元素...');
            console.log('[HTML Export] 清理前HTML长度:', clonedElement.outerHTML.length);

            const toolSelectors = [
                // 优先使用新的标记属性
                '[data-md-extractor-ui]',
                '[data-exclude-from-export]',
                // 传统的工具选择器
                '#md-extractor-toolbar',
                '#md-extractor-overlay',
                '#md-extractor-modal',
                '#manual-copy-dialog',
                '#md-extractor-preview-window',
                '#md-extractor-preview-overlay',
                '.md-extractor-highlight',
                '[id*="md-extractor"]',
                '[class*="md-extractor"]',
                '#md-extractor-styles',
                'style[id="md-extractor-styles"]',
                'div[id*="md-extractor"]',
                '*[data-md-extractor]'
            ];

            let removedCount = 0;
            toolSelectors.forEach(selector => {
                const elements = clonedElement.querySelectorAll(selector);
                console.log(`[HTML Export] 选择器 "${selector}" 找到 ${elements.length} 个元素`);
                elements.forEach(toolEl => {
                    if (toolEl.parentNode) {
                        console.log(`[HTML Export] 移除元素:`, toolEl.tagName, toolEl.id || '', toolEl.className || '');
                        toolEl.parentNode.removeChild(toolEl);
                        removedCount++;
                    }
                });
            });

            console.log(`[HTML Export] 总共移除了 ${removedCount} 个工具元素`);
            console.log('[HTML Export] 清理后HTML长度:', clonedElement.outerHTML.length);

            // 如果清理后的HTML仍然很大且包含可疑内容，警告用户
            const cleanedHtml = clonedElement.outerHTML;
            if (cleanedHtml.length > 50000 ||
                cleanedHtml.includes('copyHtmlContent') ||
                cleanedHtml.includes('downloadHtmlFile') ||
                cleanedHtml.includes('导出HTML内容') ||
                cleanedHtml.includes('导出的HTML内容')) {
                showStatus('警告: 选择范围可能过大，建议选择更具体的元素', 'error');
                console.warn('[HTML Export] 检测到可能包含工具界面的大范围选择');
                return;
            }

            // 清理所有元素上的工具相关类名，包括根元素
            // 先清理根元素
            if (clonedElement.className) {
                clonedElement.className = clonedElement.className
                    .replace(/\bmd-extractor-highlighted\b/g, '')
                    .replace(/\bmd-extractor-hover-highlight\b/g, '')
                    .replace(/\bmd-extractor-[a-zA-Z-]+\b/g, '')
                    .trim();
            }
            // 然后清理所有子元素
            const allElements = clonedElement.querySelectorAll('*');
            allElements.forEach(el => {
                if (el.className) {
                    el.className = el.className
                        .replace(/\bmd-extractor-highlighted\b/g, '')
                        .replace(/\bmd-extractor-hover-highlight\b/g, '')
                        .replace(/\bmd-extractor-[a-zA-Z-]+\b/g, '')
                        .trim();
                }
                // 移除工具相关的属性
                if (el.id && el.id.includes('md-extractor')) {
                    el.removeAttribute('id');
                }
            });

            const html = clonedElement.outerHTML;

            if (!html) {
                showStatus('导出内容为空', 'error');
                return;
            }

            // 直接处理HTML导出，不使用预览窗口
            console.log('[HTML Export] 清理后的HTML:', html);

            // 方案1: 直接复制到剪贴板
            navigator.clipboard.writeText(html).then(function() {
                showStatus(`HTML已复制到剪贴板 (${clonedElement.tagName.toLowerCase()}, ${clonedElement.textContent.length}字符)`, 'success');
                console.log('[HTML Export] HTML内容已复制到剪贴板');
            }).catch(function(err) {
                console.warn('自动复制失败:', err);
                // 方案2: 降级到手动复制
                const textarea = document.createElement('textarea');
                textarea.value = html;
                textarea.style.position = 'fixed';
                textarea.style.left = '-9999px';
                document.body.appendChild(textarea);
                textarea.select();
                const success = document.execCommand('copy');
                document.body.removeChild(textarea);

                if (success) {
                    showStatus(`HTML已复制到剪贴板 (${clonedElement.tagName.toLowerCase()}, ${clonedElement.textContent.length}字符)`, 'success');
                } else {
                    // 方案3: 提供下载
                    const blob = new Blob([html], { type: 'text/html' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'extracted_content.html';
                    a.style.display = 'none';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    showStatus(`HTML已下载到文件 (${clonedElement.tagName.toLowerCase()}, ${clonedElement.textContent.length}字符)`, 'success');
                }
            });

        } catch (error) {
            showStatus(`导出失败: ${error.message}`, 'error');
            console.error('导出HTML错误:', error);
        }
    }

    function highlightElement(selector) {
        // 清除之前的高亮
        document.querySelectorAll(`.${CONFIG.HIGHLIGHT_CLASS}`).forEach(el => {
            el.classList.remove(CONFIG.HIGHLIGHT_CLASS);
        });

        if (!selector || !selector.trim()) {
            return;
        }

        try {
            console.log('尝试高亮选择器:', selector);
            const elements = document.querySelectorAll(selector);
            console.log('找到元素数量:', elements.length);

            if (elements.length === 0) {
                console.warn('选择器未找到任何元素:', selector);
                showStatus('选择器无效：未找到匹配元素', 'error');
                return;
            }

            if (elements.length > 1) {
                console.warn('选择器匹配了多个元素:', elements.length);
                showStatus(`选择器匹配了 ${elements.length} 个元素，将高亮第一个`, 'info');
            }

            // 高亮第一个匹配的元素
            const element = elements[0];
            element.classList.add(CONFIG.HIGHLIGHT_CLASS);

            // 滚动到元素位置
            try {
                element.scrollIntoView({
                    behavior: 'smooth',
                    block: 'center',
                    inline: 'nearest'
                });
            } catch (e) {
                console.warn('滚动到元素失败:', e);
            }

            console.log('成功高亮元素:', element);

        } catch (e) {
            console.error('高亮元素失败:', selector, e);
            showStatus('选择器语法错误', 'error');
        }

    }

    // 手动提取和复制函数
    async function manualExtractAndCopy() {
        const selectorInput = document.getElementById('selector-input');
        if (!selectorInput) {
            showStatus('UI元素未找到', 'error');
            return;
        }

        const selector = selectorInput.value.trim();
        if (!selector) {
            showStatus('请先选择一个元素', 'error');
            return;
        }

        try {
            const element = document.querySelector(selector);
            if (!element) {
                showStatus('未找到元素，请重新选择', 'error');
                return;
            }

            showStatus('正在提取内容...', 'info');

            const autoExpandCheckbox = document.getElementById('auto-expand');
            if (autoExpandCheckbox && autoExpandCheckbox.checked) {
                await autoExpandContent(element);
            }

            const structuredModeCheckbox = document.getElementById('structured-mode');
            const structuredMode = structuredModeCheckbox ? structuredModeCheckbox.checked : true;

            const content = processExtraction(element, structuredMode);

            if (content && content.trim()) {
                // 直接显示手动复制界面
                showManualCopyDialog(content);
                showStatus('请手动复制内容', 'info');
            } else {
                showStatus('提取内容为空', 'error');
            }
        } catch (error) {
            showStatus(`提取失败: ${error.message}`, 'error');
            console.error("手动提取错误:", error);
        }
    }

    // iframe分析功能
    async function performIframeAnalysis() {
        showStatus('正在分析页面中的iframe...', 'info');

        try {
            const analysis = await analyzeAllIframes();
            displayIframeAnalysisResults(analysis);
        } catch (error) {
            showStatus(`iframe分析失败: ${error.message}`, 'error');
            console.error('iframe分析错误:', error);
        }
    }

    // 分析所有iframe
    async function analyzeAllIframes() {
        const iframes = document.querySelectorAll('iframe');
        const analysis = {
            totalCount: iframes.length,
            accessible: [],
            crossOrigin: [],
            empty: [],
            recommendations: []
        };

        if (iframes.length === 0) {
            analysis.recommendations.push('当前页面没有发现任何iframe元素');
            return analysis;
        }

        for (let i = 0; i < iframes.length; i++) {
            const iframe = iframes[i];
            const info = await analyzeIframeDetails(iframe, i);

            if (info.accessible) {
                analysis.accessible.push(info);
            } else if (info.crossOrigin) {
                analysis.crossOrigin.push(info);
            } else {
                analysis.empty.push(info);
            }
        }

        // 生成建议
        analysis.recommendations = generateIframeRecommendations(analysis);

        return analysis;
    }

    // 分析单个iframe的详细信息
    async function analyzeIframeDetails(iframe, index) {
        const info = {
            index: index,
            id: iframe.id || `iframe-${index}`,
            src: iframe.src || 'about:blank',
            accessible: false,
            crossOrigin: false,
            contentLength: 0,
            hasContent: false,
            dimensions: {
                width: iframe.offsetWidth,
                height: iframe.offsetHeight
            },
            content: null,
            error: null
        };

        try {
            // 尝试访问iframe内容
            const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
            if (iframeDoc) {
                info.accessible = true;

                // 提取内容
                const content = extractContentFromDocument(iframeDoc);
                if (content && content.trim()) {
                    info.hasContent = true;
                    info.contentLength = content.length;
                    info.content = content.substring(0, 500) + (content.length > 500 ? '...' : '');
                }
            }
        } catch (e) {
            // 跨域或其他访问错误
            if (e.name === 'SecurityError' || e.message.includes('cross-origin')) {
                info.crossOrigin = true;
                info.error = '跨域限制';
            } else {
                info.error = e.message;
            }
        }

        return info;
    }

    // 生成iframe处理建议
    function generateIframeRecommendations(analysis) {
        const recommendations = [];

        if (analysis.accessible.length > 0) {
            recommendations.push(`✅ 发现${analysis.accessible.length}个可直接访问的iframe，可以直接提取内容`);
        }

        if (analysis.crossOrigin.length > 0) {
            recommendations.push(`⚠️ 发现${analysis.crossOrigin.length}个跨域iframe，需要在新标签页中打开处理`);
        }

        if (analysis.empty.length > 0) {
            recommendations.push(`ℹ️ 发现${analysis.empty.length}个空iframe或无法访问的iframe`);
        }

        if (analysis.totalCount === 0) {
            recommendations.push('✅ 当前页面没有iframe，内容提取不受影响');
        }

        return recommendations;
    }

    // 显示iframe分析结果
    function displayIframeAnalysisResults(analysis) {
        const content = generateIframeAnalysisReport(analysis);
        openPreviewWindow(content, 'iframe结构分析报告');
        showStatus(`iframe分析完成：共发现${analysis.totalCount}个iframe`, 'success');
    }

    // 生成iframe分析报告
    function generateIframeAnalysisReport(analysis) {
        let report = `=== iframe结构分析报告 ===\n\n`;
        report += `总计发现: ${analysis.totalCount} 个iframe\n`;
        report += `可访问: ${analysis.accessible.length} 个\n`;
        report += `跨域限制: ${analysis.crossOrigin.length} 个\n`;
        report += `其他状态: ${analysis.empty.length} 个\n\n`;

        // 详细分析
        if (analysis.accessible.length > 0) {
            report += `📋 可访问的iframe详情:\n`;
            report += `${'='.repeat(40)}\n`;
            analysis.accessible.forEach((iframe, idx) => {
                report += `${idx + 1}. ID: ${iframe.id}\n`;
                report += `   URL: ${iframe.src}\n`;
                report += `   尺寸: ${iframe.dimensions.width}x${iframe.dimensions.height}px\n`;
                report += `   内容长度: ${iframe.contentLength} 字符\n`;
                if (iframe.hasContent && iframe.content) {
                    report += `   内容预览: ${iframe.content.replace(/\n/g, ' ')}\n`;
                }
                report += `   建议: 可直接使用选择器提取内容\n\n`;
            });
        }

        if (analysis.crossOrigin.length > 0) {
            report += `🚫 跨域iframe详情:\n`;
            report += `${'='.repeat(40)}\n`;
            analysis.crossOrigin.forEach((iframe, idx) => {
                report += `${idx + 1}. ID: ${iframe.id}\n`;
                report += `   URL: ${iframe.src}\n`;
                report += `   尺寸: ${iframe.dimensions.width}x${iframe.dimensions.height}px\n`;
                report += `   错误: ${iframe.error}\n`;
                report += `   建议: 右键点击iframe选择"在新标签页中打开"，然后在新页面使用提取工具\n\n`;
            });
        }

        if (analysis.empty.length > 0) {
            report += `❓ 其他状态iframe详情:\n`;
            report += `${'='.repeat(40)}\n`;
            analysis.empty.forEach((iframe, idx) => {
                report += `${idx + 1}. ID: ${iframe.id}\n`;
                report += `   URL: ${iframe.src}\n`;
                report += `   尺寸: ${iframe.dimensions.width}x${iframe.dimensions.height}px\n`;
                if (iframe.error) {
                    report += `   错误: ${iframe.error}\n`;
                }
                report += `   状态: 空iframe或无法访问\n\n`;
            });
        }

        // 处理建议
        report += `💡 处理建议:\n`;
        report += `${'='.repeat(40)}\n`;
        analysis.recommendations.forEach(rec => {
            report += `• ${rec}\n`;
        });

        report += `\n=== 报告结束 ===\n`;
        return report;
    }

    // 批量iframe内容提取功能
    async function performBatchIframeExtraction() {
        showStatus('开始批量提取iframe内容...', 'info');

        try {
            const results = await batchExtractIframeContents();
            displayBatchExtractionResults(results);
        } catch (error) {
            showStatus(`批量提取失败: ${error.message}`, 'error');
            console.error('批量iframe提取错误:', error);
        }
    }

    // 批量提取所有可访问iframe的内容
    async function batchExtractIframeContents() {
        const iframes = document.querySelectorAll('iframe');
        const results = {
            totalCount: iframes.length,
            successful: [],
            failed: [],
            crossOrigin: [],
            empty: []
        };

        if (iframes.length === 0) {
            throw new Error('当前页面没有发现任何iframe');
        }

        showStatus(`正在处理${iframes.length}个iframe...`, 'info');

        for (let i = 0; i < iframes.length; i++) {
            const iframe = iframes[i];
            const iframeId = iframe.id || `iframe-${i}`;

            try {
                showStatus(`正在处理iframe ${i + 1}/${iframes.length}: ${iframeId}`, 'info');

                const content = await extractSingleIframeContent(iframe, iframeId);

                if (content && content.trim()) {
                    results.successful.push({
                        id: iframeId,
                        src: iframe.src || 'about:blank',
                        content: content,
                        contentLength: content.length
                    });
                } else {
                    results.empty.push({
                        id: iframeId,
                        src: iframe.src || 'about:blank',
                        reason: '内容为空'
                    });
                }
            } catch (error) {
                if (error.message.includes('跨域') || error.message.includes('cross-origin')) {
                    results.crossOrigin.push({
                        id: iframeId,
                        src: iframe.src || 'about:blank',
                        error: error.message
                    });
                } else {
                    results.failed.push({
                        id: iframeId,
                        src: iframe.src || 'about:blank',
                        error: error.message
                    });
                }
            }
        }

        return results;
    }

    // 提取单个iframe的内容
    async function extractSingleIframeContent(iframe, iframeId) {
        return new Promise((resolve, reject) => {
            try {
                // 方法1: 直接访问同源iframe
                const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                if (iframeDoc) {
                    const content = extractContentFromDocument(iframeDoc);
                    resolve(content);
                    return;
                }
            } catch (e) {
                // 跨域限制，尝试其他方法
            }

            // 方法2: 消息通信
            let messageReceived = false;
            const timeout = setTimeout(() => {
                if (!messageReceived) {
                    reject(new Error('跨域限制或无法访问'));
                }
            }, 2000);

            const messageHandler = (event) => {
                if (event.data.type === 'iframeContent' && event.data.iframeId === iframeId) {
                    messageReceived = true;
                    clearTimeout(timeout);
                    window.removeEventListener('message', messageHandler);

                    if (event.data.content) {
                        resolve(event.data.content);
                    } else {
                        reject(new Error(event.data.error || '无法获取内容'));
                    }
                }
            };

            window.addEventListener('message', messageHandler);

            try {
                iframe.contentWindow.postMessage({
                    type: 'requestContent',
                    iframeId: iframeId
                }, '*');
            } catch (e) {
                clearTimeout(timeout);
                window.removeEventListener('message', messageHandler);
                reject(new Error('跨域限制'));
            }
        });
    }

    // 显示批量提取结果
    function displayBatchExtractionResults(results) {
        const report = generateBatchExtractionReport(results);

        // 如果有成功提取的内容，合并显示
        if (results.successful.length > 0) {
            const combinedContent = results.successful.map((item, index) => {
                return `=== iframe ${index + 1}: ${item.id} ===\n来源: ${item.src}\n长度: ${item.contentLength} 字符\n\n${item.content}\n\n`;
            }).join('\n');

            openPreviewWindow(combinedContent, `批量iframe内容 (${results.successful.length}个)`);
        }

        // 显示详细报告
        setTimeout(() => {
            openPreviewWindow(report, '批量iframe提取报告');
        }, 500);

        showStatus(`批量提取完成：成功${results.successful.length}个，失败${results.failed.length + results.crossOrigin.length}个`, 'success');
    }

    // 生成批量提取报告
    function generateBatchExtractionReport(results) {
        let report = `=== 批量iframe内容提取报告 ===\n\n`;
        report += `总计处理: ${results.totalCount} 个iframe\n`;
        report += `成功提取: ${results.successful.length} 个\n`;
        report += `跨域限制: ${results.crossOrigin.length} 个\n`;
        report += `提取失败: ${results.failed.length} 个\n`;
        report += `内容为空: ${results.empty.length} 个\n\n`;

        if (results.successful.length > 0) {
            report += `✅ 成功提取的iframe:\n`;
            report += `${'='.repeat(40)}\n`;
            results.successful.forEach((item, index) => {
                report += `${index + 1}. ID: ${item.id}\n`;
                report += `   URL: ${item.src}\n`;
                report += `   内容长度: ${item.contentLength} 字符\n`;
                report += `   状态: ✅ 提取成功\n\n`;
            });
        }

        if (results.crossOrigin.length > 0) {
            report += `🚫 跨域限制的iframe:\n`;
            report += `${'='.repeat(40)}\n`;
            results.crossOrigin.forEach((item, index) => {
                report += `${index + 1}. ID: ${item.id}\n`;
                report += `   URL: ${item.src}\n`;
                report += `   错误: ${item.error}\n`;
                report += `   建议: 在新标签页中打开处理\n\n`;
            });
        }

        if (results.failed.length > 0) {
            report += `❌ 提取失败的iframe:\n`;
            report += `${'='.repeat(40)}\n`;
            results.failed.forEach((item, index) => {
                report += `${index + 1}. ID: ${item.id}\n`;
                report += `   URL: ${item.src}\n`;
                report += `   错误: ${item.error}\n\n`;
            });
        }

        if (results.empty.length > 0) {
            report += `📄 内容为空的iframe:\n`;
            report += `${'='.repeat(40)}\n`;
            results.empty.forEach((item, index) => {
                report += `${index + 1}. ID: ${item.id}\n`;
                report += `   URL: ${item.src}\n`;
                report += `   原因: ${item.reason}\n\n`;
            });
        }

        report += `\n=== 报告结束 ===\n`;
        return report;
    }

    function showStatus(message, type = 'info') {
        const statusEl = document.getElementById('status');
        if (!statusEl) return;

        // 清除之前的定时器
        if (statusTimeout) {
            clearTimeout(statusTimeout);
        }

        statusEl.textContent = message;
        statusEl.className = `status ${type}`;

        // 5秒后清除状态
        statusTimeout = setTimeout(() => {
            statusEl.textContent = '';
            statusEl.className = 'status';
        }, 5000);

        console.log(`[MD提取器] ${type.toUpperCase()}: ${message}`);
    }

    function makeDraggable() {
        const toolbar = document.getElementById(CONFIG.TOOLBAR_ID);
        const header = toolbar ? toolbar.querySelector('.toolbar-header') : null;

        if (!toolbar || !header) return;

        let isDragging = false;
        let offsetX = 0;
        let offsetY = 0;

        function handleMouseDown(e) {
            e.preventDefault();
            isDragging = true;

            const rect = toolbar.getBoundingClientRect();
            offsetX = e.clientX - rect.left;
            offsetY = e.clientY - rect.top;

            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);

            // 添加拖拽样式
            toolbar.style.cursor = 'grabbing';
            header.style.cursor = 'grabbing';
        }

        function handleMouseMove(e) {
            if (!isDragging) return;

            e.preventDefault();

            let newX = e.clientX - offsetX;
            let newY = e.clientY - offsetY;

            // 限制在视窗范围内
            const maxX = window.innerWidth - toolbar.offsetWidth;
            const maxY = window.innerHeight - toolbar.offsetHeight;

            newX = Math.max(0, Math.min(newX, maxX));
            newY = Math.max(0, Math.min(newY, maxY));

            toolbar.style.left = `${newX}px`;
            toolbar.style.top = `${newY}px`;
            toolbar.style.right = 'auto'; // 移除right定位
        }

        function handleMouseUp() {
            isDragging = false;

            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);

            // 恢复样式
            toolbar.style.cursor = '';
            header.style.cursor = 'move';
        }

        header.addEventListener('mousedown', handleMouseDown);
    }

    // =================================================================================
    // --- 清理函数 (Cleanup) ---
    // =================================================================================
    function cleanup() {
        if (isPickingMode) {
            exitPickingMode();
        }

        if (statusTimeout) {
            clearTimeout(statusTimeout);
        }

        // 移除高亮样式
        document.querySelectorAll(`.${CONFIG.HIGHLIGHT_CLASS}`).forEach(el => {
            el.classList.remove(CONFIG.HIGHLIGHT_CLASS);
        });

        document.querySelectorAll(`.${CONFIG.HOVER_HIGHLIGHT_CLASS}`).forEach(el => {
            el.classList.remove(CONFIG.HOVER_HIGHLIGHT_CLASS);
        });
    }

    // 页面卸载时清理
    window.addEventListener('beforeunload', cleanup);

    // =================================================================================
    // --- Iframe 通信处理 (Iframe Communication) ---
    // =================================================================================

    function handleFrameMessage(event) {
        if (!isTopWindow) return;

        const { type, selector, message, iframeId, content, error } = event.data;

        switch (type) {
            case 'ping':
                // 响应嵌套窗口的ping消息
                try {
                    event.source.postMessage({ type: 'pong' }, '*');
                    console.log('[MD Extractor] 响应嵌套窗口ping');
                } catch (e) {
                    console.warn('[MD Extractor] 无法响应嵌套窗口ping:', e);
                }
                break;
            case 'elementSelected':
                console.log('收到来自 iframe 的选择器:', selector);

                // 验证iframe是否存在
                let iframeEl = null;
                if (iframeId) {
                    iframeEl = document.getElementById(iframeId);
                    if (!iframeEl) {
                        console.warn(`iframe#${iframeId} 不存在，尝试查找替代iframe`);
                        // 尝试通过其他方式找到iframe
                        const iframes = document.querySelectorAll('iframe');
                        for (let iframe of iframes) {
                            try {
                                if (iframe.contentWindow === event.source) {
                                    iframeEl = iframe;
                                    if (!iframe.id) {
                                        iframe.id = iframeId; // 设置缺失的ID
                                    }
                                    console.log('通过事件源找到匹配的iframe:', iframe.id);
                                    break;
                                }
                            } catch (e) {
                                // 跨域限制，无法访问contentWindow
                                continue;
                            }
                        }
                    }
                }

                selectionContext = { source: 'iframe', selector: selector, iframeId: iframeId };
                const selectorInput = document.getElementById('selector-input');
                if (selectorInput) {
                    selectorInput.value = selector;

                    // 只有当iframe确实存在时才尝试高亮
                    if (iframeEl) {
                        const iframeSelector = `iframe#${CSS.escape(iframeId)}`;
                        highlightElement(iframeSelector);
                    } else {
                        console.warn('无法高亮iframe，但选择器已设置');
                    }
                }
                showStatus('已从 iframe 中选择元素！', 'success');
                exitPickingMode();
                break;
            case 'selectorError':
                showStatus(message, 'error');
                exitPickingMode();
                break;
            case 'extractionResult':
                 (async () => {
                    if (error) {
                        showStatus(error, 'error');
                        return;
                    }
                    if (content && content.trim()) {
                        console.log('内容提取成功，长度:', content.length);
                        const copySuccess = await copyToClipboard(content);
                        if (!copySuccess) {
                            showManualCopyDialog(content);
                            showStatus('自动复制失败，请手动复制', 'info');
                        }
                    } else {
                        showStatus('从iframe提取内容为空', 'error');
                    }
                })();
                break;
            case 'previewResult':
                console.log('Top window received previewResult from iframe.');
                if (error) {
                    showStatus(error, 'error');
                    return;
                }
                if (content && content.trim()) {
                    openPreviewWindow(content);
                    showStatus('预览已生成', 'success');
                } else {
                    showStatus('从iframe预览内容为空', 'error');
                }
                break;
            case 'diagnosticResult':
                console.log('Top window received diagnosticResult from iframe.');
                if (error) {
                    showStatus(error, 'error');
                    return;
                }
                if (content) {
                    openPreviewWindow(content, 'DOM 遍历诊断报告 (来自 iframe)');
                    showStatus('诊断报告已生成', 'success');
                }
                break;
            case 'htmlDumpResult':
                console.log('Top window received htmlDumpResult from iframe.');
                if (error) {
                    showStatus(error, 'error');
                    return;
                }
                if (content) {
                    // 获取原始元素信息（从iframe来的内容需要解析）
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = content;
                    const originalElement = tempDiv.firstElementChild;

                    // 直接处理HTML导出，不使用预览窗口
                    console.log('[HTML Export] iframe清理后的HTML:', content);

                    // 直接复制到剪贴板
                    navigator.clipboard.writeText(content).then(function() {
                        showStatus(`HTML已复制到剪贴板 (来自iframe: ${originalElement ? originalElement.tagName.toLowerCase() : 'unknown'}, ${originalElement ? originalElement.textContent.length : 0}字符)`, 'success');
                    }).catch(function(err) {
                        console.warn('自动复制失败:', err);
                        // 降级方案
                        const blob = new Blob([content], { type: 'text/html' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'extracted_content_iframe.html';
                        a.style.display = 'none';
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        showStatus(`HTML已下载到文件 (来自iframe: ${originalElement ? originalElement.tagName.toLowerCase() : 'unknown'}, ${originalElement ? originalElement.textContent.length : 0}字符)`, 'success');
                    });
                }
                break;
            case 'htmlExportResult':
                // 处理新的HTML导出结果
                if (event.data.content) {
                    const { content, elementInfo } = event.data;
                    navigator.clipboard.writeText(content).then(function() {
                        showStatus(`HTML已复制到剪贴板 (来自iframe: ${elementInfo.tagName}, ${elementInfo.textLength}字符)`, 'success');
                    }).catch(function(err) {
                        console.warn('自动复制失败:', err);
                        const blob = new Blob([content], { type: 'text/html' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'extracted_content_iframe.html';
                        a.style.display = 'none';
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        showStatus(`HTML已下载到文件 (来自iframe: ${elementInfo.tagName}, ${elementInfo.textLength}字符)`, 'success');
                    });
                }
                break;
            case 'connectionTest':
                // 响应iframe的连接测试，确认通信正常
                console.log('[MD Extractor] 收到iframe连接测试消息');
                break;
        }
    }

    function handleMasterMessage(event) {
        if (isTopWindow) return;

        const { type, selector, autoExpand, structuredMode } = event.data;

        switch (type) {
            case 'enterPickingMode':
                debugLog('iframe 收到指令: enterPickingMode，开始进入选择模式');
                enterPickingMode();

                // 级联传递：通知子iframe
                const childIframes = document.querySelectorAll('iframe');
                if (childIframes.length > 0) {
                    debugLog(`iframe发现${childIframes.length}个子iframe，级联传递选择模式`);
                    childIframes.forEach((iframe, index) => {
                        try {
                            iframe.contentWindow.postMessage({ type: 'enterPickingMode' }, '*');
                            debugLog(`✅ 子iframe-${index} 已通知`);
                        } catch (e) {
                            debugLog(`❌ 子iframe-${index} 通知失败:`, e.message);
                        }
                    });
                }
                break;
            case 'requestContent':
                debugLog('iframe收到内容请求:', event.data.iframeId);
                handleContentRequest(event);
                break;
            case 'exitPickingMode':
                 console.log('iframe 收到指令: exitPickingMode');
                exitPickingMode();

                // 级联传递：通知子iframe
                document.querySelectorAll('iframe').forEach(iframe => {
                    try {
                        iframe.contentWindow.postMessage({ type: 'exitPickingMode' }, '*');
                    } catch (e) {
                        console.warn('iframe级联传递消息失败:', e);
                    }
                });
                break;
            case 'doExtract':
                console.log('Iframe received doExtract for selector:', selector);
                (async () => {
                    try {
                        const element = document.querySelector(selector);
                        if (!element) {
                            window.top.postMessage({ type: 'extractionResult', error: 'Iframe 错误: 未找到元素' }, '*');
                            return;
                        }
                        if (autoExpand) {
                            await autoExpandContent(element);
                        }
                        console.log('Iframe starting extraction process...');
                        const content = processExtraction(element, structuredMode);
                        console.log('Iframe finished extraction, content length:', (content || '').length);
                        console.log('Iframe sending extractionResult to top window.');
                        window.top.postMessage({ type: 'extractionResult', content: content, error: null }, '*');
                    } catch (e) {
                        window.top.postMessage({ type: 'extractionResult', content: null, error: 'Iframe 错误: ' + e.message }, '*');
                    }
                })();
                break;
            case 'doPreview':
                console.log('Iframe received doPreview for selector:', selector);
                 (async () => {
                    try {
                        const element = document.querySelector(selector);
                        if (!element) {
                            window.top.postMessage({ type: 'previewResult', error: 'Iframe 错误: 未找到元素' }, '*');
                            return;
                        }
                        if (autoExpand) {
                            await autoExpandContent(element);
                        }
                        const content = processExtraction(element, structuredMode);
                        window.top.postMessage({ type: 'previewResult', content: content, error: null }, '*');
                    } catch (e) {
                        window.top.postMessage({ type: 'previewResult', content: null, error: 'Iframe 错误: ' + e.message }, '*');
                    }
                })();
                break;
            case 'doExportHtml':
                console.log('Iframe received doExportHtml for selector:', selector);
                 (() => {
                    try {
                        const element = document.querySelector(selector);
                        if (!element) {
                            window.top.postMessage({ type: 'htmlDumpResult', error: 'Iframe 错误: 未找到元素' }, '*');
                            return;
                        }

                        // 克隆元素进行清理，避免修改原始DOM
                        const clonedElement = element.cloneNode(true);

                        // 应用与主页面相同的清理逻辑
                        // 移除垃圾元素，但保护表格内容
                        CONFIG.JUNK_SELECTORS.forEach(selector => {
                            try {
                                clonedElement.querySelectorAll(selector).forEach(junk => {
                                    // 如果是表格内的内容，跳过清理
                                    if (junk.closest('table, tbody, tr, td, th, .h-editgird, .h-editgird-wrapper, .multiRowVariableColumn')) {
                                        return;
                                    }
                                    if (junk.parentNode) {
                                        junk.parentNode.removeChild(junk);
                                    }
                                });
                            } catch (e) {
                                console.warn(`[MD Extractor] Invalid selector: ${selector}`, e);
                            }
                        });

                        // 智能清理onclick元素
                        const onClickElements = clonedElement.querySelectorAll('[onclick]');
                        onClickElements.forEach(element => {
                            if (shouldRemoveOnClickElement(element)) {
                                if (element.parentNode) {
                                    element.parentNode.removeChild(element);
                                }
                            }
                        });

                        // 移除工具自身的UI元素
                        const toolElements = clonedElement.querySelectorAll('#md-extractor-toolbar, #md-extractor-overlay, #md-extractor-modal, #manual-copy-dialog, #md-extractor-preview-window, #md-extractor-preview-overlay, .md-extractor-highlight, [id*="md-extractor"], [class*="md-extractor"], #md-extractor-styles');
                        toolElements.forEach(toolEl => {
                            if (toolEl.parentNode) {
                                toolEl.parentNode.removeChild(toolEl);
                            }
                        });

                        // 清理所有元素上的工具相关类名，包括根元素
                        // 先清理根元素
                        if (clonedElement.className) {
                            clonedElement.className = clonedElement.className
                                .replace(/\bmd-extractor-highlighted\b/g, '')
                                .replace(/\bmd-extractor-hover-highlight\b/g, '')
                                .replace(/\bmd-extractor-[a-zA-Z-]+\b/g, '')
                                .trim();
                        }
                        // 然后清理所有子元素
                        const allElements = clonedElement.querySelectorAll('*');
                        allElements.forEach(el => {
                            if (el.className) {
                                el.className = el.className
                                    .replace(/\bmd-extractor-highlighted\b/g, '')
                                    .replace(/\bmd-extractor-hover-highlight\b/g, '')
                                    .replace(/\bmd-extractor-[a-zA-Z-]+\b/g, '')
                                    .trim();
                            }
                            // 移除工具相关的属性
                            if (el.id && el.id.includes('md-extractor')) {
                                el.removeAttribute('id');
                            }
                        });

                        const html = clonedElement.outerHTML;
                        console.log('Iframe finished HTML export, content length:', (html || '').length);
                        window.top.postMessage({ type: 'htmlDumpResult', content: html, error: null }, '*');
                    } catch (e) {
                        window.top.postMessage({ type: 'htmlDumpResult', content: null, error: 'Iframe 错误: ' + e.message }, '*');
                    }
                })();
                break;
            case 'doDiagnose':
                console.log('Iframe received doDiagnose for selector:', selector);
                try {
                    const element = document.querySelector(selector);
                    if (!element) {
                        window.top.postMessage({ type: 'diagnosticResult', error: 'Iframe 错误: 未找到元素' }, '*');
                        return;
                    }
                    const report = generateDiagnosticReport(element);
                    window.top.postMessage({ type: 'diagnosticResult', content: report, error: null }, '*');
                } catch (e) {
                    window.top.postMessage({ type: 'diagnosticResult', content: null, error: 'Iframe 错误: ' + e.message }, '*');
                }
                break;
            case 'doHtmlDump':
                console.log('Iframe received doHtmlDump for selector:', selector);
                try {
                    const element = document.querySelector(selector);
                    if (!element) {
                        window.top.postMessage({ type: 'htmlDumpResult', error: 'Iframe 错误: 未找到元素' }, '*');
                        return;
                    }
                    const html = element.outerHTML;
                    const escapedHtml = html.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
                    window.top.postMessage({ type: 'htmlDumpResult', content: `<pre>${escapedHtml}</pre>`, error: null }, '*');
                } catch (e) {
                    window.top.postMessage({ type: 'htmlDumpResult', content: null, error: 'Iframe 错误: ' + e.message }, '*');
                }
                break;
        }
    }

    // =================================================================================
    // --- 诊断功能 (Diagnostics) ---
    // =================================================================================
    function generateDiagnosticReport(rootElement) {
        let report = '--- DOM 遍历诊断报告 ---\n\n';
        report += `根元素选择器: ${generateUniqueSelector(rootElement)}\n`;
        report += `根元素标签: <${rootElement.tagName.toLowerCase()}>\n`;
        report += '---------------------------\n\n';
        let nodeCount = 0;

        function traverse(node, indent = '', depth = 0) {
            if (!node || depth > 20) return; // 限制递归深度
            nodeCount++;

            const nodeType = node.nodeType;
            const tagName = node.tagName ? node.tagName.toLowerCase() : '';

            if (nodeType === (Node.TEXT_NODE || 3)) {
                const text = (node.textContent || '').trim();
                if (text) {
                    report += `${indent}- [文本] "${text}"\n`;
                }
                return;
            }

            if (nodeType !== Node.ELEMENT_NODE) {
                report += `${indent}- [非元素节点] Type: ${nodeType}\n`;
                return;
            }

            const visible = isVisible(node);
            report += `${indent}- <${tagName}> | 可见: ${visible ? '✅' : '❌'}\n`;

            if (visible) {
                Array.from(node.childNodes).forEach(child => traverse(child, indent + '  ', depth + 1));
            } else {
                const style = window.getComputedStyle(node);
                report += `${indent}  - [隐藏原因] display: ${style.display}, visibility: ${style.visibility}, opacity: ${style.opacity}\n`;
                const rect = node.getBoundingClientRect();
                report += `${indent}  - [隐藏原因] 尺寸: ${rect.width}x${rect.height}\n`;
            }
        }

        traverse(rootElement);
        report += `\n--- 报告结束 (共处理 ${nodeCount} 个节点) ---\n`;
        return report;
    }


    function openPreviewWindow(content, title = 'Markdown 预览') {
        const previewId = 'md-extractor-preview-window';
        const overlayId = 'md-extractor-preview-overlay';

        // 删除可能存在的旧预览窗口
        let existingOverlay = document.getElementById(overlayId);
        if (existingOverlay) {
            existingOverlay.remove();
        }

        // 创建遮罩层
        const overlay = document.createElement('div');
        overlay.id = overlayId;
        overlay.setAttribute('data-md-extractor-ui', 'true');
        overlay.setAttribute('data-exclude-from-export', 'true');
        overlay.style.cssText = `
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important;
            background: rgba(0, 0, 0, 0.5) !important;
            z-index: 9999998 !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
        `;

        // 创建预览窗口
        const previewWindow = document.createElement('div');
        previewWindow.id = previewId;
        previewWindow.setAttribute('data-md-extractor-ui', 'true');
        previewWindow.setAttribute('data-exclude-from-export', 'true');
        previewWindow.style.cssText = `
            width: 80vw;
            height: 80vh;
            max-width: 1000px;
            background: #fff;
            border: 1px solid #ccc;
            border-radius: 8px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            z-index: 9999999;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        `;

        previewWindow.innerHTML = `
            <div class="preview-header" style="background: #007bff; color: white; padding: 15px 20px; display: flex; justify-content: space-between; align-items: center; cursor: move;">
                <h3 style="margin: 0; font-size: 16px;">${title}</h3>
                <button class="close-preview" style="background: none; border: none; font-size: 24px; cursor: pointer; color: white; padding:0; line-height: 1;">&times;</button>
            </div>
            <div class="preview-content" style="padding: 20px; overflow: auto; flex-grow: 1; font-size: 14px; line-height: 1.6;">
                <pre style="white-space: pre-wrap; word-wrap: break-word; font-family: 'SF Mono', 'Courier New', monospace; font-size: 13px; margin: 0;">${content.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre>
            </div>
            <div class="preview-footer" style="background: #f7f7f7; padding: 15px 20px; border-top: 1px solid #e5e5e5; display: flex; justify-content: space-between; align-items: center;">
                <div style="color: #666; font-size: 12px;">
                    ${content.length} 字符, ${content.split('\n').length} 行
                </div>
                <div>
                    <button class="select-all-preview-btn" style="background: #007bff; color: white; border: none; padding: 8px 15px; border-radius: 4px; cursor: pointer; margin-right: 10px; font-size: 14px;">全选</button>
                    <button class="copy-preview-btn" style="background: #28a745; color: white; border: none; padding: 8px 15px; border-radius: 4px; cursor: pointer; margin-right: 10px; font-size: 14px;">复制</button>
                    <button class="close-preview-btn" style="background: #6c757d; color: white; border: none; padding: 8px 15px; border-radius: 4px; cursor: pointer; font-size: 14px;">关闭</button>
                </div>
            </div>
        `;

        overlay.appendChild(previewWindow);
        document.body.appendChild(overlay);

        // 绑定事件
        const close = () => {
            if (document.body.contains(overlay)) {
                document.body.removeChild(overlay);
            }
        };

        const closeBtn = previewWindow.querySelector('.close-preview');
        const closeBtnBottom = previewWindow.querySelector('.close-preview-btn');
        const selectAllBtn = previewWindow.querySelector('.select-all-preview-btn');
        const copyBtn = previewWindow.querySelector('.copy-preview-btn');
        const preContent = previewWindow.querySelector('pre');

        closeBtn.addEventListener('click', close);
        closeBtnBottom.addEventListener('click', close);

        // 全选功能
        selectAllBtn.addEventListener('click', () => {
            const range = document.createRange();
            range.selectNodeContents(preContent);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
        });

        // 复制功能
        copyBtn.addEventListener('click', async () => {
            try {
                await navigator.clipboard.writeText(content);
                copyBtn.textContent = '已复制!';
                copyBtn.style.background = '#28a745';
                setTimeout(() => {
                    copyBtn.textContent = '复制';
                    copyBtn.style.background = '#28a745';
                }, 2000);
            } catch (err) {
                console.warn('复制失败，使用备用方法');
                // 备用复制方法
                const textArea = document.createElement('textarea');
                textArea.value = content;
                textArea.style.position = 'fixed';
                textArea.style.opacity = '0';
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);

                copyBtn.textContent = '已复制!';
                setTimeout(() => {
                    copyBtn.textContent = '复制';
                }, 2000);
            }
        });

        // 点击遮罩层关闭
        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) {
                close();
            }
        });

        // ESC键关闭
        const handleKeydown = (e) => {
            if (e.key === 'Escape') {
                close();
                document.removeEventListener('keydown', handleKeydown);
            }
        };
        document.addEventListener('keydown', handleKeydown);

        // 拖拽功能
        const header = previewWindow.querySelector('.preview-header');
        let isDragging = false;
        let offsetX, offsetY;

        header.addEventListener('mousedown', (e) => {
            isDragging = true;
            const rect = previewWindow.getBoundingClientRect();
            offsetX = e.clientX - rect.left;
            offsetY = e.clientY - rect.top;
            header.style.userSelect = 'none';
            e.preventDefault();
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const newX = e.clientX - offsetX;
                const newY = e.clientY - offsetY;

                // 限制在视窗范围内
                const maxX = window.innerWidth - previewWindow.offsetWidth;
                const maxY = window.innerHeight - previewWindow.offsetHeight;

                const constrainedX = Math.max(0, Math.min(newX, maxX));
                const constrainedY = Math.max(0, Math.min(newY, maxY));

                previewWindow.style.position = 'fixed';
                previewWindow.style.left = `${constrainedX}px`;
                previewWindow.style.top = `${constrainedY}px`;
                previewWindow.style.transform = 'none';
            }
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
            header.style.userSelect = '';
        });

        // 添加按钮悬停效果
        const buttons = previewWindow.querySelectorAll('button');
        buttons.forEach(button => {
            button.addEventListener('mouseenter', () => {
                if (button.classList.contains('select-all-preview-btn')) {
                    button.style.background = '#0056b3';
                } else if (button.classList.contains('copy-preview-btn')) {
                    button.style.background = '#218838';
                } else if (button.classList.contains('close-preview-btn')) {
                    button.style.background = '#5a6268';
                }
            });

            button.addEventListener('mouseleave', () => {
                if (button.classList.contains('select-all-preview-btn')) {
                    button.style.background = '#007bff';
                } else if (button.classList.contains('copy-preview-btn')) {
                    button.style.background = '#28a745';
                } else if (button.classList.contains('close-preview-btn')) {
                    button.style.background = '#6c757d';
                }
            });
        });
    }


    function isVisible(el) {
        if (!(el instanceof Element)) {
            return true; // Text nodes, etc., are considered "visible" by default.
        }

        // For data extraction, we should be more lenient. We only care if an element is truly removed from the layout.
        // We walk up the tree to check for `display: none`.
        // We ignore `visibility`, `opacity`, and zero-size rects because content can be
        // programmatically hidden but still be valid data (e.g., in inactive tabs or scrollable areas).
        let current = el;
        while (current && current !== document.body) {
            if (window.getComputedStyle(current).display === 'none') {
                return false;
            }
            current = current.parentElement;
        }

        return true;
    }

    // About对话框
    function showAboutDialog() {
        const existingDialog = document.getElementById('agom-about-dialog');
        if (existingDialog) {
            existingDialog.remove();
        }

        const dialog = document.createElement('div');
        dialog.id = 'agom-about-dialog';
        dialog.innerHTML = `
            <div class="about-overlay">
                <div class="about-content">
                    <div class="about-header">
                        <h3>📝 Agom Markdown提取器</h3>
                        <button class="about-close-btn">×</button>
                    </div>
                    <div class="about-body">
                        <p><strong>版本：</strong> v${SCRIPT_VERSION}</p>
                        <p><strong>作者：</strong> Agom Liou</p>
                        <p><strong>微信：</strong> uncleliou</p>
                        <p><strong>功能：</strong> 智能提取网页内容并转换为Markdown格式</p>
                        <div class="about-actions">
                            <button class="donate-btn">💰 支持作者</button>
                            <button class="close-about-btn">关闭</button>
                        </div>
                    </div>
                </div>
            </div>
        `;

        const style = document.createElement('style');
        style.textContent = `
            .about-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: rgba(0, 0, 0, 0.5);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 999999;
            }
            .about-content {
                background: white;
                border-radius: 8px;
                width: 400px;
                max-width: 90vw;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            }
            .about-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 20px;
                border-bottom: 1px solid #eee;
            }
            .about-header h3 {
                margin: 0;
                color: #333;
                font-size: 18px;
            }
            .about-close-btn {
                background: none;
                border: none;
                font-size: 24px;
                cursor: pointer;
                color: #999;
                padding: 0;
                width: 30px;
                height: 30px;
                display: flex;
                justify-content: center;
                align-items: center;
            }
            .about-body {
                padding: 20px;
            }
            .about-body p {
                margin: 10px 0;
                color: #666;
                line-height: 1.5;
            }
            .about-actions {
                margin-top: 20px;
                display: flex;
                gap: 10px;
                justify-content: flex-end;
            }
            .donate-btn, .close-about-btn {
                padding: 8px 16px;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
            }
            .donate-btn {
                background: #ff6b35;
                color: white;
            }
            .close-about-btn {
                background: #6c757d;
                color: white;
            }
            .donate-btn:hover {
                background: #e55a2e;
            }
            .close-about-btn:hover {
                background: #5a6268;
            }
        `;

        dialog.appendChild(style);
        document.body.appendChild(dialog);

        // 绑定事件
        dialog.querySelector('.about-close-btn').addEventListener('click', () => {
            dialog.remove();
        });
        dialog.querySelector('.close-about-btn').addEventListener('click', () => {
            dialog.remove();
        });
        dialog.querySelector('.donate-btn').addEventListener('click', () => {
            showPaymentQR();
        });
        dialog.querySelector('.about-overlay').addEventListener('click', (e) => {
            if (e.target === dialog.querySelector('.about-overlay')) {
                dialog.remove();
            }
        });
    }

    // 显示收款码
    function showPaymentQR() {
        const existingQR = document.getElementById('agom-payment-qr');
        if (existingQR) {
            existingQR.remove();
        }

        const qrDialog = document.createElement('div');
        qrDialog.id = 'agom-payment-qr';
        qrDialog.innerHTML = `
            <div class="qr-overlay">
                <div class="qr-content">
                    <div class="qr-header">
                        <h3>💰 支持作者</h3>
                        <button class="qr-close-btn">×</button>
                    </div>
                    <div class="qr-body">
                        <p>如果这个脚本对您有帮助，可以打赏我一些您卖班成功后的小时工资</p>
                        <img src="data:image/png;base64,${PAYMENT_QR_BASE64}" alt="收款码" style="width: 200px; height: 200px; margin: 10px auto; display: block;">
                        <p style="text-align: center; color: #666; margin-top: 10px;">微信扫码支持</p>
                    </div>
                </div>
            </div>
        `;

        const qrStyle = document.createElement('style');
        qrStyle.textContent = `
            .qr-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: rgba(0, 0, 0, 0.5);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 999999;
            }
            .qr-content {
                background: white;
                border-radius: 8px;
                width: 320px;
                max-width: 90vw;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            }
            .qr-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 20px;
                border-bottom: 1px solid #eee;
            }
            .qr-header h3 {
                margin: 0;
                color: #333;
                font-size: 18px;
            }
            .qr-close-btn {
                background: none;
                border: none;
                font-size: 24px;
                cursor: pointer;
                color: #999;
                padding: 0;
                width: 30px;
                height: 30px;
                display: flex;
                justify-content: center;
                align-items: center;
            }
            .qr-body {
                padding: 20px;
                text-align: center;
            }
            .qr-body p {
                margin: 10px 0;
                color: #666;
                line-height: 1.5;
            }
        `;

        qrDialog.appendChild(qrStyle);
        document.body.appendChild(qrDialog);

        // 绑定事件
        qrDialog.querySelector('.qr-close-btn').addEventListener('click', () => {
            qrDialog.remove();
        });
        qrDialog.querySelector('.qr-overlay').addEventListener('click', (e) => {
            if (e.target === qrDialog.querySelector('.qr-overlay')) {
                qrDialog.remove();
            }
        });
    }

    // 每日提示功能 - 已禁用
    function checkDailyReminder() {
        // 打赏弹窗已禁用
        return;
    }

    // 在页面加载完成后执行每日提示检查
    if (isTopWindow) {
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', checkDailyReminder);
        } else {
            setTimeout(checkDailyReminder, 1000);
        }
    }


})();